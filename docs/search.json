[{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Overview","title":null,"text":"emergence high-resolution spatial omics technologies revolutionized ability map cellular ecosystems situ. workshop explores approaches multi-sample spatial data analysis. cover end--end workflow considerations—experimental design QC spatial feature interpretation—case studies disease prediction. dataset Assumed knowledge Learning objectives subset widely-known METABRIC breast cancer cohort recently analyzed using imaging mass cytometry: Imaging Mass Cytometry Multiplatform Genomics Define Phenogenomic Landscape Breast Cancer. Patient clinical data sourced Supplementary Table 5 Dynamics Breast-cancer Relapse Reveal Late-recurring ER-positive Genomic Subgroups. Experience R. Familiarity SingleCellExperiment class. Basic knowledge single cell data analysis. can access previous workshops quick tutorial. Ability install required R packages, please check sessionInfo end document ensure using correct versions. Familiarity previous workshop vignette Introduction Single Cell RNA-seq Analysis. Describe visualise spatial omics datasets. Understand approaches quality control spatial proteomics data. Calculate spatial statistics cell-type level using scFeatures. Perform multi-view disease outcome prediction package ClassifyR. evaluation classification survival models . evaluate cohort heterogeneity given survival model. Explore various strategies disease outcome prognosis using spatial omics data. question interest want know risk recurrence METABRIC breast cancer cohort can accurately estimated inform aggressively need treated.","code":""},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Part 0: Loading an example image in R","title":null,"text":"begin, start loading example image R. neccessary familiar part, provide pre-processed data rest workshop. DNA staining image Mask Overlay","code":"suppressPackageStartupMessages({   library(cytomapper)   library(EBImage)   library(S4Vectors) })  img_path  <- \"../data/raw_image_example/MB0002_1_345_fullstack.tiff\" mask_path <- \"../data/raw_image_example/MB0002_1_345_cellmask.tiff\" sample_id <- \"../data/raw_image_example/MB0002_1_345\"  #Load image (multi-channel) images <- loadImages(img_path, single_channel = FALSE) names(images) <- sample_id #Load mask mask_img <- readImage(mask_path,as.is =T) masks <- CytoImageList(list(mask_img)) names(masks) <- sample_id  # Add metadata rows so img_id can be matched by COLUMN NAME mcols(images) <- DataFrame(sample_id = names(images)) mcols(masks)  <- DataFrame(sample_id = names(masks))  # Build channel names from CSVs and assign them metal_order <- read.csv(\"../data/raw_image_example/channel_to_metal_order.csv\",                         header = FALSE, stringsAsFactors = FALSE) names(metal_order) <- \"metal\" metal_order$Channel <- seq_len(nrow(metal_order))  metal_map <- read.csv(\"../data/raw_image_example/metal_to_marker.csv\",                       header = TRUE, stringsAsFactors = FALSE)  merged <- merge(metal_order, metal_map, by = \"metal\", all.x = TRUE) merged <- merged[order(merged$Channel), ] labels <- ifelse(is.na(merged$marker), merged$metal, merged$marker)  # Assign channel names to the multi-channel image channelNames(images) <- labels marker = plotPixels(   image = images,   colour_by = \"Total HH3\" ) # Plot the mask plotCells(masks) # Plot overlay  combine = plotPixels(   image    = images,   mask     = masks,   img_id   = \"sample_id\",      # column name in mcols(images)/mcols(masks)   colour_by = \"Total HH3\"      )"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Part 1: Exploring the data","title":null,"text":"start analysis pipeline, often good explore data get sense structure complexity. Let’s explore data answer questions : Questions many features observations data features represent? covariates data? Given question interest, variable outcome variable?  SCE object Data overview Covariates First, take quick look structure SingleCell Experiment object. , take quick look rows columns represent dimensions data. addition proteomics data, ’s important understand covariates, clinical variables, dataset. can help us answering question(s) interest formulate new questions. example, can’t explore association smoking status breast cancer severity variable smoking status doesn’t exist data. Now basic idea data looks like, can look detail. initial data exploration reveals fundamental patterns, deeper examination helpful. serves two critical purposes: first, detect anomalies biases requiring remediation, second, inform choice analytical methods tailored biological questions hand. Missing values Imbalance Relationships Visualise cells Examining proportion missing values dataset crucial ensuring accuracy validity data analysis. Missing values can significantly impact reliability statistical results, potentially leading biased conclusions reduced statistical power. , plot proportion missing values clinical variables.  Looking imbalance data crucial can lead biased models inaccurate predictions, especially classification tasks. Imbalance occurs one class significantly underrepresented compared others. can cause models overly influenced majority class, leading poor performance minority class. , tabularise relevant clinical variables plot distribution Time Recurrence-Free Survival variable.     , explore distribution outcomes variables meta-data. use cross-tabulation examine following variables: Surgery vs death, ER status, Grade. assess potential batch effects sample-specific clustering patterns, visualize cells data colored sample origin. qualitative inspection provides intuitive first assessment batch effects data integration. batch effects ’d need apply batch correction resolve issue.  Discussion anomalies biases might need corrected ensure analysis robust? Given question interest characteristics data, particular analytic techniques appropriate? appropriate?","code":"# Load data load(\"../data/breastCancer.RData\") data_sce = IMC  # Structure of our data data_sce class: SingleCellExperiment  dim: 38 76307  metadata(0): assays(2): counts logcounts rownames(38): HH3_total CK19 ... H3K27me3 CK5 rowData names(0): colnames(76307): MB-0002:345:93 MB-0002:345:107 ... MB-0663:394:577   MB-0663:394:578 colData names(17): file_id metabricId ... x_cord y_cord reducedDimNames(1): UMAP mainExpName: NULL altExpNames(0): # Metadata #DT::datatable(data.frame(colData(data_sce))) head(data.frame(colData(data_sce))) file_id metabricId core_id ImageNumber ObjectNumber MB-0002:345:93  MB0002_1_345    MB-0002       1         345           93 MB-0002:345:107 MB0002_1_345    MB-0002       1         345          107 MB-0002:345:113 MB0002_1_345    MB-0002       1         345          113 MB-0002:345:114 MB0002_1_345    MB-0002       1         345          114 MB-0002:345:125 MB0002_1_345    MB-0002       1         345          125 MB-0002:345:127 MB0002_1_345    MB-0002       1         345          127                 Fibronectin Location_Center_X Location_Center_Y SOM_nodes MB-0002:345:93    0.4590055          179.7088          27.90110       130 MB-0002:345:107   0.1176471          193.0588          29.29412       131 MB-0002:345:113   0.2512903          162.1935          28.83871        83 MB-0002:345:114   0.4788444          198.3111          29.15556       128 MB-0002:345:125   6.1901112          262.8889          31.26667         7 MB-0002:345:127   0.6897432          136.0946          32.98649       130                 pg_cluster    description   region      ki67 MB-0002:345:93          54       HR- CK7- region_1  low_ki67 MB-0002:345:107         54       HR- CK7- region_4  low_ki67 MB-0002:345:113         28    HRlow CKlow region_1 high_ki67 MB-0002:345:114         54       HR- CK7- region_4 high_ki67 MB-0002:345:125         11 Myofibroblasts region_2  low_ki67 MB-0002:345:127         54       HR- CK7- region_1  low_ki67                               celltype  sample   x_cord   y_cord MB-0002:345:93        HR- CK7--region1 MB-0002 179.7088 27.90110 MB-0002:345:107       HR- CK7--region4 MB-0002 193.0588 29.29412 MB-0002:345:113    HRlow CKlow-region1 MB-0002 162.1935 28.83871 MB-0002:345:114       HR- CK7--region4 MB-0002 198.3111 29.15556 MB-0002:345:125 Myofibroblasts-region2 MB-0002 262.8889 31.26667 MB-0002:345:127       HR- CK7--region1 MB-0002 136.0946 32.98649 # Glimpse the first few observations  head(colnames(data_sce)) [1] \"MB-0002:345:93\"  \"MB-0002:345:107\" \"MB-0002:345:113\" \"MB-0002:345:114\" [5] \"MB-0002:345:125\" \"MB-0002:345:127\" # Glimpse the first few features head(rownames(data_sce)) [1] \"HH3_total\" \"CK19\"      \"CK8_18\"    \"Twist\"     \"CD68\"      \"CK14\" # How many features and observations are in our dataset? dim(data_sce) [1]    38 76307 # Explore covariates  # DT::datatable(clinical) colnames(colData(data_sce)) [1] \"file_id\"           \"metabricId\"        \"core_id\"            [4] \"ImageNumber\"       \"ObjectNumber\"      \"Fibronectin\"        [7] \"Location_Center_X\" \"Location_Center_Y\" \"SOM_nodes\"         [10] \"pg_cluster\"        \"description\"       \"region\"            [13] \"ki67\"              \"celltype\"          \"sample\"            [16] \"x_cord\"            \"y_cord\" # What is the proportion of missing values in our clinical data? gg_miss_var(clinical, show_pct = TRUE) + theme_bw() # Estrogen receptor status ggplot(clinical, aes(x = ER.Status)) +    geom_bar(fill = \"#0099B4\", color = \"white\", alpha = 0.8) +   labs(y = \"Count\\n\",         x = \"\\nER status\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # Histological type ggplot(clinical, aes(x = Histological.Type)) +    geom_bar(fill = \"#fc6203\", color = \"white\", alpha = 0.8) +   labs(y = \"Count\\n\",         x = \"\\nHistological Type\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # eventRFS: \"Event in Recurrence-Free Survival.\"It indicates whether the event has occurred.# ggplot(clinical, aes(x = factor(eventRFS))) +    geom_bar(fill = \"#40dbb2\", color = \"white\", alpha = 0.8) +   labs(y = \"Count\\n\",         x = \"\\nEvent in Recurrence-Free Survival\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # timeRFS: \"Time to Recurrence-Free Survival.\" It is the time period until recurrence occurs.  ggplot(clinical, aes(x = timeRFS)) +    geom_histogram(fill = \"#de9921\", color = \"white\", alpha = 0.8, bins=20) +   labs(y = \"Frequency\\n\",         x = \"\\ntimeRFS\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # Stage and death table(clinical$Breast.Surgery, clinical$Death, useNA = \"ifany\") 0  1   BREAST CONSERVING 38 14   MASTECTOMY        16  6   <NA>               2  1 # ER status and grade table(clinical$ER.Status, clinical$Grade) 1  2  3   neg  0  0 11   pos 13 30 17 # \"Number of individuals based on Grade table(clinical$Grade, clinical$Death) 0  1   1 12  2   2 25  5   3 17 11 #data_sce <- runUMAP(data_sce, scale=TRUE)  # With the UMAP function we can highlight by meta data of interest # Here we highlight the UMAP by sample ID plotUMAP(data_sce, colour_by = \"metabricId\") + theme(legend.position = \"none\") +   coord_equal()"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"1.1: Initial data exploration","title":null,"text":"start analysis pipeline, often good explore data get sense structure complexity. Let’s explore data answer questions : Questions many features observations data features represent? covariates data? Given question interest, variable outcome variable?  SCE object Data overview Covariates First, take quick look structure SingleCell Experiment object. , take quick look rows columns represent dimensions data. addition proteomics data, ’s important understand covariates, clinical variables, dataset. can help us answering question(s) interest formulate new questions. example, can’t explore association smoking status breast cancer severity variable smoking status doesn’t exist data.","code":"# Load data load(\"../data/breastCancer.RData\") data_sce = IMC  # Structure of our data data_sce class: SingleCellExperiment  dim: 38 76307  metadata(0): assays(2): counts logcounts rownames(38): HH3_total CK19 ... H3K27me3 CK5 rowData names(0): colnames(76307): MB-0002:345:93 MB-0002:345:107 ... MB-0663:394:577   MB-0663:394:578 colData names(17): file_id metabricId ... x_cord y_cord reducedDimNames(1): UMAP mainExpName: NULL altExpNames(0): # Metadata #DT::datatable(data.frame(colData(data_sce))) head(data.frame(colData(data_sce))) file_id metabricId core_id ImageNumber ObjectNumber MB-0002:345:93  MB0002_1_345    MB-0002       1         345           93 MB-0002:345:107 MB0002_1_345    MB-0002       1         345          107 MB-0002:345:113 MB0002_1_345    MB-0002       1         345          113 MB-0002:345:114 MB0002_1_345    MB-0002       1         345          114 MB-0002:345:125 MB0002_1_345    MB-0002       1         345          125 MB-0002:345:127 MB0002_1_345    MB-0002       1         345          127                 Fibronectin Location_Center_X Location_Center_Y SOM_nodes MB-0002:345:93    0.4590055          179.7088          27.90110       130 MB-0002:345:107   0.1176471          193.0588          29.29412       131 MB-0002:345:113   0.2512903          162.1935          28.83871        83 MB-0002:345:114   0.4788444          198.3111          29.15556       128 MB-0002:345:125   6.1901112          262.8889          31.26667         7 MB-0002:345:127   0.6897432          136.0946          32.98649       130                 pg_cluster    description   region      ki67 MB-0002:345:93          54       HR- CK7- region_1  low_ki67 MB-0002:345:107         54       HR- CK7- region_4  low_ki67 MB-0002:345:113         28    HRlow CKlow region_1 high_ki67 MB-0002:345:114         54       HR- CK7- region_4 high_ki67 MB-0002:345:125         11 Myofibroblasts region_2  low_ki67 MB-0002:345:127         54       HR- CK7- region_1  low_ki67                               celltype  sample   x_cord   y_cord MB-0002:345:93        HR- CK7--region1 MB-0002 179.7088 27.90110 MB-0002:345:107       HR- CK7--region4 MB-0002 193.0588 29.29412 MB-0002:345:113    HRlow CKlow-region1 MB-0002 162.1935 28.83871 MB-0002:345:114       HR- CK7--region4 MB-0002 198.3111 29.15556 MB-0002:345:125 Myofibroblasts-region2 MB-0002 262.8889 31.26667 MB-0002:345:127       HR- CK7--region1 MB-0002 136.0946 32.98649 # Glimpse the first few observations  head(colnames(data_sce)) [1] \"MB-0002:345:93\"  \"MB-0002:345:107\" \"MB-0002:345:113\" \"MB-0002:345:114\" [5] \"MB-0002:345:125\" \"MB-0002:345:127\" # Glimpse the first few features head(rownames(data_sce)) [1] \"HH3_total\" \"CK19\"      \"CK8_18\"    \"Twist\"     \"CD68\"      \"CK14\" # How many features and observations are in our dataset? dim(data_sce) [1]    38 76307 # Explore covariates  # DT::datatable(clinical) colnames(colData(data_sce)) [1] \"file_id\"           \"metabricId\"        \"core_id\"            [4] \"ImageNumber\"       \"ObjectNumber\"      \"Fibronectin\"        [7] \"Location_Center_X\" \"Location_Center_Y\" \"SOM_nodes\"         [10] \"pg_cluster\"        \"description\"       \"region\"            [13] \"ki67\"              \"celltype\"          \"sample\"            [16] \"x_cord\"            \"y_cord\""},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"1.2: Is this a complex dataset?","title":null,"text":"Now basic idea data looks like, can look detail. initial data exploration reveals fundamental patterns, deeper examination helpful. serves two critical purposes: first, detect anomalies biases requiring remediation, second, inform choice analytical methods tailored biological questions hand. Missing values Imbalance Relationships Visualise cells Examining proportion missing values dataset crucial ensuring accuracy validity data analysis. Missing values can significantly impact reliability statistical results, potentially leading biased conclusions reduced statistical power. , plot proportion missing values clinical variables.  Looking imbalance data crucial can lead biased models inaccurate predictions, especially classification tasks. Imbalance occurs one class significantly underrepresented compared others. can cause models overly influenced majority class, leading poor performance minority class. , tabularise relevant clinical variables plot distribution Time Recurrence-Free Survival variable.     , explore distribution outcomes variables meta-data. use cross-tabulation examine following variables: Surgery vs death, ER status, Grade. assess potential batch effects sample-specific clustering patterns, visualize cells data colored sample origin. qualitative inspection provides intuitive first assessment batch effects data integration. batch effects ’d need apply batch correction resolve issue.  Discussion anomalies biases might need corrected ensure analysis robust? Given question interest characteristics data, particular analytic techniques appropriate? appropriate?","code":"# What is the proportion of missing values in our clinical data? gg_miss_var(clinical, show_pct = TRUE) + theme_bw() # Estrogen receptor status ggplot(clinical, aes(x = ER.Status)) +    geom_bar(fill = \"#0099B4\", color = \"white\", alpha = 0.8) +   labs(y = \"Count\\n\",         x = \"\\nER status\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # Histological type ggplot(clinical, aes(x = Histological.Type)) +    geom_bar(fill = \"#fc6203\", color = \"white\", alpha = 0.8) +   labs(y = \"Count\\n\",         x = \"\\nHistological Type\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # eventRFS: \"Event in Recurrence-Free Survival.\"It indicates whether the event has occurred.# ggplot(clinical, aes(x = factor(eventRFS))) +    geom_bar(fill = \"#40dbb2\", color = \"white\", alpha = 0.8) +   labs(y = \"Count\\n\",         x = \"\\nEvent in Recurrence-Free Survival\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # timeRFS: \"Time to Recurrence-Free Survival.\" It is the time period until recurrence occurs.  ggplot(clinical, aes(x = timeRFS)) +    geom_histogram(fill = \"#de9921\", color = \"white\", alpha = 0.8, bins=20) +   labs(y = \"Frequency\\n\",         x = \"\\ntimeRFS\") +   theme_minimal() +   theme(plot.title = element_text(hjust = 0.5, face = \"bold\")) # Stage and death table(clinical$Breast.Surgery, clinical$Death, useNA = \"ifany\") 0  1   BREAST CONSERVING 38 14   MASTECTOMY        16  6   <NA>               2  1 # ER status and grade table(clinical$ER.Status, clinical$Grade) 1  2  3   neg  0  0 11   pos 13 30 17 # \"Number of individuals based on Grade table(clinical$Grade, clinical$Death) 0  1   1 12  2   2 25  5   3 17 11 #data_sce <- runUMAP(data_sce, scale=TRUE)  # With the UMAP function we can highlight by meta data of interest # Here we highlight the UMAP by sample ID plotUMAP(data_sce, colour_by = \"metabricId\") + theme(legend.position = \"none\") +   coord_equal()"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Part 2: Quality control","title":null,"text":", explore key approaches evaluating quality IMC data. robust assessment consider multiple factors, including density marker expression, marker correlations, co-expression. Something might want think characeristics might indicate whether sample(s) low/high quality? , want assess quality markers: desirable see least two peaks, indicate existence cell type specific markers data. Questions Can see cell type specific markers, ? non-cell type specific markers? can notice distribution markers across images? assess whether marker intensities require transformation normalisation. step important two main reasons: Skewed distributions: Marker intensities often right-skewed, can distort downstream analyses clustering dimensionality reduction. Inconsistent scales across images: Due technical variation, marker may show different intensity ranges across images. can shift ’s considered “positive” “negative” expression, making difficult label cells accurately. applying transformation normalisation, aim stabilise variance bring data onto comparable scale across images.  CD20 CD3 CD68 vWF_CD31 Vimentin HER2       ’re looking CD31+ CD31- peaks clearly separate density plot? ensure downstream analysis goes smoothly, want cell type specific markers show 2 distinct peaks representing CD31+ CD31- cells. see 3 peaks don’t expect, might indicator normalisation required. CD31+ CD31- peaks consistent across images? want make sure density plots CD3 largely across images CD3+ cell one image equivalent CD3+ cell another image.  plot , normalised data appeas bimodal. can observe one clear CD31- peak around 0.50, CD31+ peak 1.00. Image-level batch effects also appear mitigated, since peaks occur around CD31 intensity. Discussion sufficient amount cell type specific markers? panel genes sufficient study?  plot correlation different markers subset samples. helps us determine whether sample low/high contamination markers. Questions pairs markers expect correlated/correlated. evidence marker contamination given sample?  MB-0002 MB-0064 MB-0128 MB-0130 MB-0132 MB-0136 MB-0138 MB-0142 MB-0145 MB-0154 MB-0168 MB-0175 MB-0180 MB-0192 MB-0201 MB-0208 MB-0225 MB-0227 MB-0232 MB-0240 MB-0245 MB-0246 MB-0249 MB-0252 MB-0255 MB-0256 MB-0258 MB-0260 MB-0263 MB-0275 MB-0308 MB-0318 MB-0320 MB-0347 MB-0351 MB-0367 MB-0377 MB-0383 MB-0394 MB-0397 MB-0400 MB-0401 MB-0405 MB-0410 MB-0420 MB-0439 MB-0451 MB-0454 MB-0455 MB-0461 MB-0463 MB-0467 MB-0470 MB-0475 MB-0480 MB-0481 MB-0487 MB-0498 MB-0508 MB-0516 MB-0518 MB-0520 MB-0531 MB-0536 MB-0571 MB-0584 MB-0591 MB-0596 MB-0604 MB-0605 MB-0628 MB-0635 MB-0636 MB-0642 MB-0661 MB-0662 MB-0663                                                                              Questions samples like remove data? samples like keep?   Another way QC data explore whether DE genes associations find matches current literature. example, breast cancer cohort. Breast cancer well studied easy perform DE analysis pseudobulking data see makes findings previous bulk RNA-seq studies breast cancer cohorts. can also single-cell level compare previous single-cell proteomic/RNA-seq studies breast cancer cohorts. won’t running code . example one might perform basic DE analysis using package limma. , can also check whether cell type annotations make sense. One way check whether marker expression levels agree cell type annotations. example, expect CD3 highly expressed T cells, CD20 highly expressed B cells, CD68 highly expressed Macrophages, vWF_CD31 highly expressed Endothelial cells, Vimentin highly expressed Fibroblasts, HER2 highly expressed Tumor HER2+ cells.  Discussion might check whether results make sense? potential issues might find?","code":"cell_counts <- IMC@colData |>  as.data.frame() |>   dplyr::count(metabricId, name = \"cell_count\") |>  # Count rows per metabricId   dplyr::arrange(desc(cell_count))   reducedDim(IMC, \"spatialCoords\") <- IMC@colData[,c(\"Location_Center_X\",\"Location_Center_Y\")]   cell_type_mapping <- c(   \"B cells\" = \"B cell\",   \"T cells\" = \"T cell\",   \"Macrophages Vim+ CD45low\" = \"Macrophage\",   \"Macrophages Vim+ Slug-\" = \"Macrophage\",   \"Macrophages Vim+ Slug+\" = \"Macrophage\",    \"Endothelial\" = \"Endothelial\",    \"Fibroblasts\" = \"Fibroblast\",   \"Fibroblasts CD68+\" = \"Fibroblast\",   \"Myofibroblasts\" = \"Fibroblast\",   \"Vascular SMA+\" = \"Fibroblast\",    \"Myoepithelial\" = \"Myoepithelial\",    \"HR+ CK7-\" = \"Tumor HR+\",   \"HR+ CK7- Ki67+\" = \"Tumor HR+\",   \"HR+ CK7- Slug+\" = \"Tumor HR+\",    \"HR- CK7+\" = \"Tumor HR-\",   \"HR- CK7-\" = \"Tumor HR-\",   \"HR- Ki67+\" = \"Tumor HR-\",   \"HR- CKlow CK5+\" = \"Tumor HR-\",    \"HRlow CKlow\" = \"Tumor HR-low/mixed\",   \"HER2+\" = \"Tumor HER2+\",   \"Basal CKlow\" = \"Tumor Basal-like\",   \"Hypoxia\" = \"Tumor Hypoxic\" )  # Convert IMC description to higher-level categories IMC$high_level_category <- recode(IMC$description, !!!cell_type_mapping)   imc.spe=IMC[,IMC$metabricId%in%cell_counts[1:20,]$metabricId]  # Convert IMC description to higher-level categories imc.spe$high_level_category <- recode(imc.spe$description, !!!cell_type_mapping)   plots <- plot_marker_densities(imc.spe, sample_id_col = \"metabricId\",                                 markers_to_plot = c(\"CD20\",\"CD3\",\"CD68\",\"vWF_CD31\",\"Vimentin\",\"HER2\"),                                assay_name = \"logcounts\") # leave out the nuclei markers from our normalisation process useMarkers <- rownames(data_sce)[!rownames(data_sce) %in% c(\"DNA1\", \"DNA2\", \"HH3\", \"HH3_total\", \"HH3_ph\")]  # transform and normalise the marker expression of each cell type data_sce <- normalizeCells(data_sce,                         markers = useMarkers,                         transformation = NULL,                         method = c(\"trim99\", \"minMax\", \"PC1\"),                         assayIn = \"counts\",                         imageID = \"metabricId\")  selected_patients = which(colData(data_sce)$metabricId %in% cell_counts[1:10,]$metabricId)  norm = plot_marker_densities(data_sce[,selected_patients], sample_id_col = \"metabricId\", markers_to_plot = \"vWF_CD31\", assay_name = \"norm\")$vWF_CD31 + theme(legend.position = \"none\") + ggtitle(\"Normalized Counts - CD31\")  log = plot_marker_densities(data_sce[,selected_patients], sample_id_col = \"metabricId\", markers_to_plot = c(\"vWF_CD31\"), assay_name = \"logcounts\")$vWF_CD31 + theme(legend.position = \"none\") + ggtitle(\"Log Counts - CD31\")  ggarrange(log, norm, ncol=2) coexp_df <- readRDS(\"../data/coexp_df.rds\") marker_list <- c(\"CD20\", \"CD3\", \"CD68\", \"vWF_CD31\", \"Vimentin\", \"HER2\")   # Proportion heatmaps heatmaps_prop <- plot_pairwise_heatmaps_per_sample(coexp_df, marker_list, stat = \"proportion\") cell_counts <- IMC@colData |>  as.data.frame() |>   dplyr::count(metabricId, name = \"cell_count\") |>  # Count rows per metabricId   dplyr::arrange(desc(cell_count))    mean_coexp_per_sample <- coexp_df %>%   select(-cell_id, -cell_type) %>%  # remove columns not related to prob values   group_by(metabricId) %>%   summarise(mean_coexp_prob = mean(c_across(where(is.numeric)), na.rm = TRUE)) %>%   ungroup()   merged_df <- left_join(mean_coexp_per_sample, cell_counts, by = \"metabricId\")  # Scatter plot ggplot(merged_df, aes(x = cell_count, y = mean_coexp_prob)) +   geom_point(size = 3, color = \"steelblue\") +    labs(     x = \"Cell Count per Sample\",     y = \"Mean Co-expression\",     title = \"Mean Co-expression vs. Cell Count\"   ) +   theme_minimal(base_size = 14) # Note: The same approach can be used for pseudobulk or single-cell level data.  # Just change `logcounts(data_sce)`  # We want low ki67 to be the reference level (baseline level)  data_sce$ki67 <- factor(data_sce$ki67, levels=c(\"low_ki67\", \"high_ki67\"))  # Here we specify the design matrix. We are specifying that Y are the expression values and X is ki67 status (but it could be any other variable - such as \"good\" or \"bad\" prognosis) # Y~X: Expression as a function of ki67 status.  design_matrix <- model.matrix(~data_sce$ki67)  # Fit model fit <- lmFit(assay(data_sce, \"norm\"), design = design_matrix)  # Estimate variance and SE of coefficients fit <- eBayes(fit)  tt <- topTable(fit, coef = 2, n = 5, adjust.method = \"BH\", sort.by = \"p\") tt logFC   AveExpr         t       P.Value     adj.P.Val HH3_total   2.99807594 5.3783014 126.61566  0.000000e+00  0.000000e+00 HH3_ph      0.22158959 0.3549916  67.81304  0.000000e+00  0.000000e+00 Ki67        0.07903174 0.1129605  65.26755  0.000000e+00  0.000000e+00 E_cadherin  0.03507204 0.5389372  31.99330 4.085283e-223 3.881019e-222 H3K27me3   -0.03479189 0.4609833 -30.33584 6.094169e-201 4.631568e-200                    B HH3_total  7265.7780 HH3_ph     2222.8176 Ki67       2062.7347 E_cadherin  498.5455 H3K27me3    447.5419 # Calculate average expression per cell type avg_expr <- aggregate(t(assay(data_sce, \"norm\")),                        by = list(CellType = IMC$high_level_category),                        FUN = mean) %>%   tibble::column_to_rownames(var = \"CellType\")  avg_expr <- avg_expr[, c(\"CD20\", \"CD3\", \"CD68\", \"CD45\",                           \"vWF_CD31\", \"Vimentin\", \"HER2\")]  # select only our mark  # Plot heatmap of marker by celltype pheatmap(avg_expr, scale = \"column\", main = \"Average Marker Expression per Cell Type\\n\",           cluster_rows = FALSE,          color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(10000))"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"2.1: QC for the panel / markers","title":null,"text":", want assess quality markers: desirable see least two peaks, indicate existence cell type specific markers data. Questions Can see cell type specific markers, ? non-cell type specific markers? can notice distribution markers across images? assess whether marker intensities require transformation normalisation. step important two main reasons: Skewed distributions: Marker intensities often right-skewed, can distort downstream analyses clustering dimensionality reduction. Inconsistent scales across images: Due technical variation, marker may show different intensity ranges across images. can shift ’s considered “positive” “negative” expression, making difficult label cells accurately. applying transformation normalisation, aim stabilise variance bring data onto comparable scale across images.  CD20 CD3 CD68 vWF_CD31 Vimentin HER2       ’re looking CD31+ CD31- peaks clearly separate density plot? ensure downstream analysis goes smoothly, want cell type specific markers show 2 distinct peaks representing CD31+ CD31- cells. see 3 peaks don’t expect, might indicator normalisation required. CD31+ CD31- peaks consistent across images? want make sure density plots CD3 largely across images CD3+ cell one image equivalent CD3+ cell another image.  plot , normalised data appeas bimodal. can observe one clear CD31- peak around 0.50, CD31+ peak 1.00. Image-level batch effects also appear mitigated, since peaks occur around CD31 intensity. Discussion sufficient amount cell type specific markers? panel genes sufficient study?","code":"# leave out the nuclei markers from our normalisation process useMarkers <- rownames(data_sce)[!rownames(data_sce) %in% c(\"DNA1\", \"DNA2\", \"HH3\", \"HH3_total\", \"HH3_ph\")]  # transform and normalise the marker expression of each cell type data_sce <- normalizeCells(data_sce,                         markers = useMarkers,                         transformation = NULL,                         method = c(\"trim99\", \"minMax\", \"PC1\"),                         assayIn = \"counts\",                         imageID = \"metabricId\")  selected_patients = which(colData(data_sce)$metabricId %in% cell_counts[1:10,]$metabricId)  norm = plot_marker_densities(data_sce[,selected_patients], sample_id_col = \"metabricId\", markers_to_plot = \"vWF_CD31\", assay_name = \"norm\")$vWF_CD31 + theme(legend.position = \"none\") + ggtitle(\"Normalized Counts - CD31\")  log = plot_marker_densities(data_sce[,selected_patients], sample_id_col = \"metabricId\", markers_to_plot = c(\"vWF_CD31\"), assay_name = \"logcounts\")$vWF_CD31 + theme(legend.position = \"none\") + ggtitle(\"Log Counts - CD31\")  ggarrange(log, norm, ncol=2)"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"Part 2: Quality control","what":"Normalisation of marker expression","title":null,"text":"’re looking CD31+ CD31- peaks clearly separate density plot? ensure downstream analysis goes smoothly, want cell type specific markers show 2 distinct peaks representing CD31+ CD31- cells. see 3 peaks don’t expect, might indicator normalisation required. CD31+ CD31- peaks consistent across images? want make sure density plots CD3 largely across images CD3+ cell one image equivalent CD3+ cell another image.  plot , normalised data appeas bimodal. can observe one clear CD31- peak around 0.50, CD31+ peak 1.00. Image-level batch effects also appear mitigated, since peaks occur around CD31 intensity. Discussion sufficient amount cell type specific markers? panel genes sufficient study?","code":"# leave out the nuclei markers from our normalisation process useMarkers <- rownames(data_sce)[!rownames(data_sce) %in% c(\"DNA1\", \"DNA2\", \"HH3\", \"HH3_total\", \"HH3_ph\")]  # transform and normalise the marker expression of each cell type data_sce <- normalizeCells(data_sce,                         markers = useMarkers,                         transformation = NULL,                         method = c(\"trim99\", \"minMax\", \"PC1\"),                         assayIn = \"counts\",                         imageID = \"metabricId\")  selected_patients = which(colData(data_sce)$metabricId %in% cell_counts[1:10,]$metabricId)  norm = plot_marker_densities(data_sce[,selected_patients], sample_id_col = \"metabricId\", markers_to_plot = \"vWF_CD31\", assay_name = \"norm\")$vWF_CD31 + theme(legend.position = \"none\") + ggtitle(\"Normalized Counts - CD31\")  log = plot_marker_densities(data_sce[,selected_patients], sample_id_col = \"metabricId\", markers_to_plot = c(\"vWF_CD31\"), assay_name = \"logcounts\")$vWF_CD31 + theme(legend.position = \"none\") + ggtitle(\"Log Counts - CD31\")  ggarrange(log, norm, ncol=2)"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"2.2: QC of individual samples","title":null,"text":"plot correlation different markers subset samples. helps us determine whether sample low/high contamination markers. Questions pairs markers expect correlated/correlated. evidence marker contamination given sample?  MB-0002 MB-0064 MB-0128 MB-0130 MB-0132 MB-0136 MB-0138 MB-0142 MB-0145 MB-0154 MB-0168 MB-0175 MB-0180 MB-0192 MB-0201 MB-0208 MB-0225 MB-0227 MB-0232 MB-0240 MB-0245 MB-0246 MB-0249 MB-0252 MB-0255 MB-0256 MB-0258 MB-0260 MB-0263 MB-0275 MB-0308 MB-0318 MB-0320 MB-0347 MB-0351 MB-0367 MB-0377 MB-0383 MB-0394 MB-0397 MB-0400 MB-0401 MB-0405 MB-0410 MB-0420 MB-0439 MB-0451 MB-0454 MB-0455 MB-0461 MB-0463 MB-0467 MB-0470 MB-0475 MB-0480 MB-0481 MB-0487 MB-0498 MB-0508 MB-0516 MB-0518 MB-0520 MB-0531 MB-0536 MB-0571 MB-0584 MB-0591 MB-0596 MB-0604 MB-0605 MB-0628 MB-0635 MB-0636 MB-0642 MB-0661 MB-0662 MB-0663","code":"coexp_df <- readRDS(\"../data/coexp_df.rds\") marker_list <- c(\"CD20\", \"CD3\", \"CD68\", \"vWF_CD31\", \"Vimentin\", \"HER2\")   # Proportion heatmaps heatmaps_prop <- plot_pairwise_heatmaps_per_sample(coexp_df, marker_list, stat = \"proportion\")"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"2.3: QC of study as a whole","title":null,"text":"Questions samples like remove data? samples like keep?","code":"cell_counts <- IMC@colData |>  as.data.frame() |>   dplyr::count(metabricId, name = \"cell_count\") |>  # Count rows per metabricId   dplyr::arrange(desc(cell_count))    mean_coexp_per_sample <- coexp_df %>%   select(-cell_id, -cell_type) %>%  # remove columns not related to prob values   group_by(metabricId) %>%   summarise(mean_coexp_prob = mean(c_across(where(is.numeric)), na.rm = TRUE)) %>%   ungroup()   merged_df <- left_join(mean_coexp_per_sample, cell_counts, by = \"metabricId\")  # Scatter plot ggplot(merged_df, aes(x = cell_count, y = mean_coexp_prob)) +   geom_point(size = 3, color = \"steelblue\") +    labs(     x = \"Cell Count per Sample\",     y = \"Mean Co-expression\",     title = \"Mean Co-expression vs. Cell Count\"   ) +   theme_minimal(base_size = 14)"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"2.4: Does my data agree with literature?","title":null,"text":"Another way QC data explore whether DE genes associations find matches current literature. example, breast cancer cohort. Breast cancer well studied easy perform DE analysis pseudobulking data see makes findings previous bulk RNA-seq studies breast cancer cohorts. can also single-cell level compare previous single-cell proteomic/RNA-seq studies breast cancer cohorts. won’t running code . example one might perform basic DE analysis using package limma.","code":"# Note: The same approach can be used for pseudobulk or single-cell level data.  # Just change `logcounts(data_sce)`  # We want low ki67 to be the reference level (baseline level)  data_sce$ki67 <- factor(data_sce$ki67, levels=c(\"low_ki67\", \"high_ki67\"))  # Here we specify the design matrix. We are specifying that Y are the expression values and X is ki67 status (but it could be any other variable - such as \"good\" or \"bad\" prognosis) # Y~X: Expression as a function of ki67 status.  design_matrix <- model.matrix(~data_sce$ki67)  # Fit model fit <- lmFit(assay(data_sce, \"norm\"), design = design_matrix)  # Estimate variance and SE of coefficients fit <- eBayes(fit)  tt <- topTable(fit, coef = 2, n = 5, adjust.method = \"BH\", sort.by = \"p\") tt logFC   AveExpr         t       P.Value     adj.P.Val HH3_total   2.99807594 5.3783014 126.61566  0.000000e+00  0.000000e+00 HH3_ph      0.22158959 0.3549916  67.81304  0.000000e+00  0.000000e+00 Ki67        0.07903174 0.1129605  65.26755  0.000000e+00  0.000000e+00 E_cadherin  0.03507204 0.5389372  31.99330 4.085283e-223 3.881019e-222 H3K27me3   -0.03479189 0.4609833 -30.33584 6.094169e-201 4.631568e-200                    B HH3_total  7265.7780 HH3_ph     2222.8176 Ki67       2062.7347 E_cadherin  498.5455 H3K27me3    447.5419"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"2.5: Cell Type Classification","title":null,"text":", can also check whether cell type annotations make sense. One way check whether marker expression levels agree cell type annotations. example, expect CD3 highly expressed T cells, CD20 highly expressed B cells, CD68 highly expressed Macrophages, vWF_CD31 highly expressed Endothelial cells, Vimentin highly expressed Fibroblasts, HER2 highly expressed Tumor HER2+ cells.  Discussion might check whether results make sense? potential issues might find?","code":"# Calculate average expression per cell type avg_expr <- aggregate(t(assay(data_sce, \"norm\")),                        by = list(CellType = IMC$high_level_category),                        FUN = mean) %>%   tibble::column_to_rownames(var = \"CellType\")  avg_expr <- avg_expr[, c(\"CD20\", \"CD3\", \"CD68\", \"CD45\",                           \"vWF_CD31\", \"Vimentin\", \"HER2\")]  # select only our mark  # Plot heatmap of marker by celltype pheatmap(avg_expr, scale = \"column\", main = \"Average Marker Expression per Cell Type\\n\",           cluster_rows = FALSE,          color = colorRampPalette(c(\"blue\", \"white\", \"red\"))(10000))"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Part 3: Exploring spatial data","title":null,"text":"section assumes pre-existing cell type annotations. unannotated data, two primary annotation strategies available: Unsupervised approach: cluster cells identify marker genes manual annotation. Supervised approach: transfer labels reference datasets using supervised learning/classification tools. supervised annotation, recommend scClassify, robust framework cell-type classification. visualise data without spatial information exploring data . Following initial assessment potential batch effects sample-origin visualization, now examine cell-type-specific clustering patterns. Distinct, biologically meaningful clusters emerge annotated cell type. presence heterogeneous clusters containing unrelated cell types may indicate incomplete inaccurate cell-type annotations.  advantage spatial omics can examine organisation cell-types occurs tissue slide. , visualise one slides patient. select particular patient “MB-0002” visualise tissue sample patient using ggplot. see spatial patterning look randomly distributed?  Questions kinds spatial information might interest given question ’d like answer? might try capture spatial relationships?  Spatial regions Spatial regions detection across multiple individuals (Banksy) Across individuals (Optional) Specific regions (Optional) Background: One common questions analyses spatial data spatial domain detection. “Spatial domains” regions within tissue cells share similar gene expression profiles physically clustered together. , use terminology “spatial domain” “regions” interchangeably. common analytical strategies involve spatial clustering, different methods use different levels information, gene expression data , cell type information, spatial coordinates. strategy demonstrate uses lisaClust function, uses cell type information cluster cells five distinct spatial regions. case study, compare individuals good poor prognosis examine graphically see regions appear different good poor prognosis. define: - Good prognosis individuals > 10 years recurrence-free survival - Poor prognosis individuals < 5 years recurrence-free survival. visualise spatial domain (regions) detection result based one individual. use terminology “spatial domain” “regions” interchangeably. Depending number regions, may useful visualise spatial regions either collectively single graph separately multiple graphs. visualise single graph, hatchingPlot() function used create hatching patterns representating spatial regions cell-types.   written small function draw_region_clustering_result visualise data separately multiple graphs individual MB-0002.   Discussion ’d like examine multiple individuals, better visualise information?  perform spatial region detection across multiple individuals, use Banksy package. Banksy method identifies spatial regions integrating gene expression spatial information. code perform spatial region detection using Banksy visualise results.  can also visualise spatial region detection results across multiple individuals side side comparison. example visualising two individuals, MB-0002 MB-0064. Notice different cell type compositions different regions two individuals.  can better interpret region output summarising proportion cell-type region across individuals. look composition cell-types region compare prognostic outcomes.  number sub-cell types increase considerably want add spatial domain (region) information. enhance clarity facilitate understanding, may helpful choose predetermined region. code generates set boxplots enable comparison cell-type proportions individuals good poor prognosis region_5.","code":"plotUMAP(data_sce, colour_by = \"description\") # obtaining the meta data for this patient  one_sample <- data_sce[, data_sce$metabricId  == \"MB-0002\"] one_sample  <- data.frame(colData(one_sample))   ggplot(one_sample, aes(x = Location_Center_X, y = Location_Center_Y, colour = description)) +    geom_point(alpha=0.7) +    theme(panel.background=element_blank(),         axis.line=element_line(color=\"black\")) +   ggtitle(\"Original slide\") ## Extract time to recurrence-free survival clinical$survivalgroup <- \"neither\"  ## Define poor and good prognosis clinical$survivalgroup[which( clinical$timeRFS  < 5* 365) ] <- \"poor\"  clinical$survivalgroup[which( clinical$timeRFS  > 10* 365) ] <-  \"good\"  ## To visualise it in a single graph hatchingPlot(   data_sce,   region = \"region\",   imageID = \"metabricId\",   cellType = \"description\",   spatialCoords = c(\"Location_Center_X\", \"Location_Center_Y\") ) draw_region_clustering_result(data_sce ,                                sample = \"metabricId\" ,                                selected_sample =  \"MB-0002\" ) [[1]] [[2]] library(Banksy) library(SpatialExperiment) library(cowplot)  ### The code below takes a while to run, so we have saved the output as an RDS file that can be loaded directly.  # spe_base <- SpatialExperiment( #   assays = assays(data_sce), #   rowData = rowData(data_sce), #   colData = colData(data_sce), #   spatialCoords = as.matrix(colData(data_sce)[, c(\"Location_Center_X\", \"Location_Center_Y\")]) # ) # assay_to_use <- if (\"counts\" %in% assayNames(spe_base)) \"counts\" else assayNames(spe_base)[1] # sample_ids <- unique(spe_base$metabricId) # spe_list <- lapply(sample_ids, function(id) { #   spe_subset <- spe_base[, spe_base$metabricId == id] #   Banksy::computeBanksy( #     spe_subset, #     assay_name = assay_to_use, #     k_geom = 18 #   ) # }) # spe_joint <- do.call(cbind, spe_list) # spe_joint <- Banksy::runBanksyPCA( #   spe_joint, #   lambda = 0.8, #   npcs = 30, #   group = \"metabricId\" # ) # spe_joint <- Banksy::clusterBanksy( #   spe_joint, #   lambda = 0.8, #   npcs = 30, #   algo = \"kmeans\", #   kmeans.centers = 5 # ) # clust_col <- grep(\"^clust_\", colnames(colData(spe_joint)), value = TRUE)[1] # data_sce$banksy_region <- colData(spe_joint)[colnames(data_sce), clust_col]  banksy_ouput_spe_joint <- readRDS(\"../data/banksy_ouput_spe_joint.rds\")  hatchingPlot(   banksy_ouput_spe_joint,   region = \"banksy_region\",   imageID = \"metabricId\",   cellType = \"description\",   spatialCoords = c(\"Location_Center_X\", \"Location_Center_Y\") ) samples_to_plot <- c(\"MB-0002\", \"MB-0064\") plot_list <- lapply(samples_to_plot, function(id) {   idx <- banksy_ouput_spe_joint$metabricId == id   if (!any(idx)) return(NULL)   hatchingPlot(     banksy_ouput_spe_joint[, idx],     region = \"banksy_region\",     imageID = \"metabricId\",     cellType = \"description\",     spatialCoords = c(\"Location_Center_X\", \"Location_Center_Y\")   ) + ggtitle(id) }) plot_list <- plot_list[!vapply(plot_list, is.null, logical(1))] cowplot::plot_grid(plotlist = plot_list, ncol = 2) draw_dotplot(data_sce,                sample = \"metabricId\" ,               celltype = \"description\" ,                group= \"survivalgroup\" ,               group_of_interest =  c(\"poor\" , \"good\")) `summarise()` has grouped output by 'Var1', 'Var2'. You can override using the `.groups` argument. draw_selected_region_boxplot(data_sce,                               sample = \"metabricId\" ,                               celltype =\"description\" ,                               group  = \"survivalgroup\",                               group_of_interest =  c(\"poor\" , \"good\"),                               select_region = \"region_5\")"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"Part 3: Exploring spatial data","what":"Cell types","title":null,"text":"Following initial assessment potential batch effects sample-origin visualization, now examine cell-type-specific clustering patterns. Distinct, biologically meaningful clusters emerge annotated cell type. presence heterogeneous clusters containing unrelated cell types may indicate incomplete inaccurate cell-type annotations.","code":"plotUMAP(data_sce, colour_by = \"description\")"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"Part 3: Exploring spatial data","what":"Spatial structure","title":null,"text":"advantage spatial omics can examine organisation cell-types occurs tissue slide. , visualise one slides patient. select particular patient “MB-0002” visualise tissue sample patient using ggplot. see spatial patterning look randomly distributed?  Questions kinds spatial information might interest given question ’d like answer? might try capture spatial relationships?  Spatial regions Spatial regions detection across multiple individuals (Banksy) Across individuals (Optional) Specific regions (Optional) Background: One common questions analyses spatial data spatial domain detection. “Spatial domains” regions within tissue cells share similar gene expression profiles physically clustered together. , use terminology “spatial domain” “regions” interchangeably. common analytical strategies involve spatial clustering, different methods use different levels information, gene expression data , cell type information, spatial coordinates. strategy demonstrate uses lisaClust function, uses cell type information cluster cells five distinct spatial regions. case study, compare individuals good poor prognosis examine graphically see regions appear different good poor prognosis. define: - Good prognosis individuals > 10 years recurrence-free survival - Poor prognosis individuals < 5 years recurrence-free survival. visualise spatial domain (regions) detection result based one individual. use terminology “spatial domain” “regions” interchangeably. Depending number regions, may useful visualise spatial regions either collectively single graph separately multiple graphs. visualise single graph, hatchingPlot() function used create hatching patterns representating spatial regions cell-types.   written small function draw_region_clustering_result visualise data separately multiple graphs individual MB-0002.   Discussion ’d like examine multiple individuals, better visualise information?  perform spatial region detection across multiple individuals, use Banksy package. Banksy method identifies spatial regions integrating gene expression spatial information. code perform spatial region detection using Banksy visualise results.  can also visualise spatial region detection results across multiple individuals side side comparison. example visualising two individuals, MB-0002 MB-0064. Notice different cell type compositions different regions two individuals.  can better interpret region output summarising proportion cell-type region across individuals. look composition cell-types region compare prognostic outcomes.  number sub-cell types increase considerably want add spatial domain (region) information. enhance clarity facilitate understanding, may helpful choose predetermined region. code generates set boxplots enable comparison cell-type proportions individuals good poor prognosis region_5.","code":"# obtaining the meta data for this patient  one_sample <- data_sce[, data_sce$metabricId  == \"MB-0002\"] one_sample  <- data.frame(colData(one_sample))   ggplot(one_sample, aes(x = Location_Center_X, y = Location_Center_Y, colour = description)) +    geom_point(alpha=0.7) +    theme(panel.background=element_blank(),         axis.line=element_line(color=\"black\")) +   ggtitle(\"Original slide\") ## Extract time to recurrence-free survival clinical$survivalgroup <- \"neither\"  ## Define poor and good prognosis clinical$survivalgroup[which( clinical$timeRFS  < 5* 365) ] <- \"poor\"  clinical$survivalgroup[which( clinical$timeRFS  > 10* 365) ] <-  \"good\"  ## To visualise it in a single graph hatchingPlot(   data_sce,   region = \"region\",   imageID = \"metabricId\",   cellType = \"description\",   spatialCoords = c(\"Location_Center_X\", \"Location_Center_Y\") ) draw_region_clustering_result(data_sce ,                                sample = \"metabricId\" ,                                selected_sample =  \"MB-0002\" ) [[1]] [[2]] library(Banksy) library(SpatialExperiment) library(cowplot)  ### The code below takes a while to run, so we have saved the output as an RDS file that can be loaded directly.  # spe_base <- SpatialExperiment( #   assays = assays(data_sce), #   rowData = rowData(data_sce), #   colData = colData(data_sce), #   spatialCoords = as.matrix(colData(data_sce)[, c(\"Location_Center_X\", \"Location_Center_Y\")]) # ) # assay_to_use <- if (\"counts\" %in% assayNames(spe_base)) \"counts\" else assayNames(spe_base)[1] # sample_ids <- unique(spe_base$metabricId) # spe_list <- lapply(sample_ids, function(id) { #   spe_subset <- spe_base[, spe_base$metabricId == id] #   Banksy::computeBanksy( #     spe_subset, #     assay_name = assay_to_use, #     k_geom = 18 #   ) # }) # spe_joint <- do.call(cbind, spe_list) # spe_joint <- Banksy::runBanksyPCA( #   spe_joint, #   lambda = 0.8, #   npcs = 30, #   group = \"metabricId\" # ) # spe_joint <- Banksy::clusterBanksy( #   spe_joint, #   lambda = 0.8, #   npcs = 30, #   algo = \"kmeans\", #   kmeans.centers = 5 # ) # clust_col <- grep(\"^clust_\", colnames(colData(spe_joint)), value = TRUE)[1] # data_sce$banksy_region <- colData(spe_joint)[colnames(data_sce), clust_col]  banksy_ouput_spe_joint <- readRDS(\"../data/banksy_ouput_spe_joint.rds\")  hatchingPlot(   banksy_ouput_spe_joint,   region = \"banksy_region\",   imageID = \"metabricId\",   cellType = \"description\",   spatialCoords = c(\"Location_Center_X\", \"Location_Center_Y\") ) samples_to_plot <- c(\"MB-0002\", \"MB-0064\") plot_list <- lapply(samples_to_plot, function(id) {   idx <- banksy_ouput_spe_joint$metabricId == id   if (!any(idx)) return(NULL)   hatchingPlot(     banksy_ouput_spe_joint[, idx],     region = \"banksy_region\",     imageID = \"metabricId\",     cellType = \"description\",     spatialCoords = c(\"Location_Center_X\", \"Location_Center_Y\")   ) + ggtitle(id) }) plot_list <- plot_list[!vapply(plot_list, is.null, logical(1))] cowplot::plot_grid(plotlist = plot_list, ncol = 2) draw_dotplot(data_sce,                sample = \"metabricId\" ,               celltype = \"description\" ,                group= \"survivalgroup\" ,               group_of_interest =  c(\"poor\" , \"good\")) `summarise()` has grouped output by 'Var1', 'Var2'. You can override using the `.groups` argument. draw_selected_region_boxplot(data_sce,                               sample = \"metabricId\" ,                               celltype =\"description\" ,                               group  = \"survivalgroup\",                               group_of_interest =  c(\"poor\" , \"good\"),                               select_region = \"region_5\")"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Part 4: Feature engineering with scFeatures","title":null,"text":", use scFeatures generate molecular features individual using features x cells matrices. features interpretable can used downstream analyses. general, scFeatures generates features across six categories: Cell-type proportions. Cell-type specific gene expressions. Cell-type specific pathway expressions. Cell-type interaction scores. Aggregated gene expressions. Spatial metrics: Nearest neighbour’s correlation, L statistics, Moran’s . different types features constructed enable comprehensive multi-view understanding individual. default, function generate total 13 different types features stored 13 samples x features matrices, one feature type. section, examine spatial information two perspectives. Utilising spatial domain detection described part 3, select specific region interest create molecular representations region individual (Section 4.1). Second, utilise spatial statistics capture spatial relationships within region interest, Moran’s (Section 4.2) , can consider regional information following code allows us create cell-type specific features region. use function “paste0” construct region-specific sub cell-types name celltype R object data_sce. simplicity, workshop, variable celltype R object data_sce refers region-specific sub-cell-types. total 13 different types features (feature_types) can choose generate. argument type refers type input data . either scrna (single-cell RNA-sequencing data), spatial_p (spatial proteomics data), spatial_t (single-cell spatial data). section, ignore spatial information generate non-spatial features, pseudobulking sample /cell type levels, overall expression, cell type proportions etc… Generate features ROI Association Study scFeatures code (Optional) scFeatures output (Optional) Suppose interested determining proportion cell-types within region individual. necessary specify type = spatial_p reflect spatial proteomics data feature_types = proportion_raw indicate intend calculate cell-type proportions region-specific cell-types. Suppose interested molecular representation HR- CK7+ within individuals within region 5. Question regions associated “good” “poor” prognosis? right way visualise results?   Can identify “differential expression” feature interest? R object scfeatures_result contains variety features. important question focuses identification features reflect association prognostic outcome, specifically distinguishing good poor outcomes. code provided demonstrates use limma() function fit linear model purpose analysing gene_mean_celltype illustration feature type. feature type known gene_mean_celltype represents mean protein expression sub-cell-type specific spatial region. matrix consisting 77 individuals 4180 features. important acknowledge within context IMC data, term “gene” used refer “protein”. visualise comparison using volcano plot dotplot cell-type specific expression feature. type scatter-plot used quickly identify changes large datasets represent significance (y-axis) versus effect size fold-change (x-axis).  code enable us generate feature types cell-types line. Due limitations today’s computational capacity, Please run today’s workshop, crash system. Assuming already generated collection molecular representation individuals, please load prepared RDS file scfeatures_result.RDS. , can remind generated feature types stored matrix samples x features. now look spatial statistic output scFeatures qualitively assess whether association statistics “good” “bad” prognosis groups. Questions kind information spatial statistics provide? differences distribution spatial statistics “good” “bad” prognosis groups?  Nearest neighbour correlation L statistics Moran’s metric measures correlation proteins/genes cell nearest neighbour cell.  L function spatial statistic used assess spatial distribution cell-types. assesses significance cell-cell interactions, calculating density cell-type cell-types within certain radius. High values indicate spatial association (co-localisation), low values indicate spatial avoidance. demonstrate L-function, plot specific patient “MB-0128” high L value B cells interacting Fibroblasts low L value B cells interacting HR- CK7- cells.  Moran’s spatial autocorrelation statistic based location values. quantifies whether similar values tend occur near dispersed.","code":"region <- data_sce$region  # Define a series of sub-cell-types that is regional specific data_sce$celltype <- paste0( data_sce$description , \"-\" , region) ## [A] The next few lines extract specific information from data_sce as input to scFeatures.  ## Extract the expression matrix from data_sce IMCmatrix <- assay(data_sce, \"norm\")  ## Extract the sample information  ## append the condition to the individuals so we can easily retrieve the individuals condition  sample <- data_sce$metabricId  cond  <- clinical[match(sample, clinical$metabricId), ]$survivalgroup sample <- paste0(sample, \"_cond_\", cond )   ## Extract the region-specific sub-cell-types celltype <- data_sce$celltype  ## Extract the spatial coordinates spatialCoords <- list(colData(data_sce)$Location_Center_X, colData(data_sce)$Location_Center_Y)  ### [B] Running scFeatures scfeatures_result <- scFeatures(IMCmatrix,                                  sample = sample,                                  celltype = celltype,                                  spatialCoords = spatialCoords,                                 feature_types = \"proportion_raw\",                                  type = \"spatial_p\" ) ## [A] The next few lines extract specific information from data_sce as input to scFeatures.  ## Select the HR- CK7+-region sub-cell-type   # There are different ways you can use `scFeatures` to generate molecular representations for individuals and it requires the following information for spatial data. #  # data,\\ # sample, # X coordinates, # Y coordinates, # feature_types, and # type  index <- grep(\"HR- CK7+-region\" , data_sce$celltype, fixed=TRUE) selected_data <- IMCmatrix[, index] selected_sample <- sample[index] selected_celltype <- data_sce$celltype[ index]  selected_spatialCoords <- list(colData(data_sce)$Location_Center_X[index],                                 colData(data_sce)$Location_Center_Y[index])  ### [B] Running scFeatures scfeatures_result <- scFeatures( selected_data,                                   sample = selected_sample,                                   celltype = selected_celltype,                                  spatialCoords = selected_spatialCoords,                                  feature_types = \"proportion_raw\", type = \"spatial_p\" )  ### [C] Visualize the regional composition makeup for each individual for HR- CK7+ and HR- CK7- feature <- scfeatures_result$proportion_raw feature <- feature[ grep(\"poor|good\", rownames(feature)),  ]  plot_barplot(feature ) + ggtitle(\"Proportion raw feature\") + labs(y = \"proportion\\n\") scfeatures_result <- readRDS(\"../data/scfeatures_result.RDS\") # Extract cell-type specific gene expression for all regions.  gene_mean_celltype <- scfeatures_result$gene_mean_celltype  # Extract HR+ CK7 cell-type specific gene expression for Region5 index <-  grep(\"HR+ CK7--region5\", colnames(gene_mean_celltype) , fixed= T) gene_mean_celltype <- gene_mean_celltype [, index]   # transpose to ensure we have gene by sample matrix gene_mean_celltype <- t(gene_mean_celltype)        # Extract the two conditions of interest - poor prognosis vs good prognosis condition  <- unlist( lapply( strsplit( colnames(gene_mean_celltype) , \"_cond_\"), `[`, 2)) condition <- data.frame(sample = colnames(gene_mean_celltype), condition = condition ) select_index <- which( condition$condition %in% c(\"poor\",  \"good\" )) condition <- condition[ select_index, ] gene_mean_celltype<- gene_mean_celltype [ ,  select_index]   # Calculate log fold change each protein using limma design <- model.matrix(~condition, data = condition) fit <- lmFit(gene_mean_celltype, design) fit <- eBayes(fit) tT <- topTable(fit, n = Inf) tT$gene <- rownames(tT) tT[1:6] <- signif(tT[1:6], digits=2) DT::datatable(tT) # order the proteins by log fold change  tT <- tT[ order(tT$logFC, decreasing = T), ] tT <- tT[1:20, ] ggplot( tT , aes( y = reorder(gene, logFC) , x = logFC  ) )+       geom_point(aes(colour=-log10(P.Value)), alpha=2/3, size=4) +       scale_colour_gradient(low=\"blue\",high=\"red\") + theme_bw() +        xlab(\"logFC\") + ylab(\"region specific cell type specfic features\" ) # here, we specify that this is a spatial proteomics data # scFeatures support parallel computation to speed up the process  # scfeatures_result <- scFeatures(IMCmatrix,  #                                 type = \"spatial_p\", #                                 sample = sample,  #                                 celltype = celltype,  #                                 spatialCoords = spatialCoords, #                                 ncores = 32) # Upload pre-generated RDS file scfeatures_result <- readRDS(\"../data/scfeatures_result.RDS\")  # What are the features and the dimensions of features matrices that we have generated? lapply(scfeatures_result, dim) $proportion_raw [1]  77 110  $proportion_logit [1]  77 110  $proportion_ratio [1]   77 5995  $gene_mean_celltype [1]   77 4180  $gene_prop_celltype [1]   77 4180  $gene_cor_celltype [1]    77 27958  $gene_mean_bulk [1] 77 38  $gene_prop_bulk [1] 77 38  $gene_cor_bulk [1]  77 703  $L_stats [1]   77 3842  $celltype_interaction [1]   77 4393  $morans_I [1] 77 38  $nn_correlation [1] 77 38 feature <- scfeatures_result$nn_correlation feature <- feature[ grep(\"poor|good\", rownames(feature )),  ]  top_features <- feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   group_by(variable) %>%   summarise(     cohens_d = (mean(value[Group == \"Good Prognosis\"]) - mean(value[Group == \"Poor Prognosis\"])) /sd(value),     .groups = \"drop\"   ) %>%   arrange(desc(abs(cohens_d))) %>%   slice_head(n = 5) %>%   pull(variable)  feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   filter(variable %in% top_features) %>%  # Keep only top 5   ggplot(aes(y = variable, x = value, fill = Group)) +    geom_boxplot() + theme_bw() + labs(x = \"Nearest Neighbour Correlation\", y = \"Marker\") tableau_palette <- scale_colour_tableau( palette = \"Tableau 20\") color_codes <- tableau_palette$palette(10)  # Create a named color vector cell_colors <- c(   \"B cells\" = color_codes[1],   \"Fibroblasts\" = color_codes[2],   \"HR- CK7-\" = color_codes[9],   \"others\" = color_codes[4] )  # select one patient  one_sample  <- data_sce[ , data_sce$metabricId == \"MB-0128\"  ] one_sample <- data.frame( colData(one_sample) )  one_sample$celltype <- one_sample$description  # High L-function value plot. one_sample <- data.frame(colData(data_sce[, data_sce$metabricId == \"MB-0128\"])) one_sample$celltype <- one_sample$description index <- one_sample$celltype %in% c(\"B cells\", \"Fibroblasts\") one_sample$celltype[!index] <- \"others\" a <- ggplot(one_sample, aes(x = Location_Center_X, y = Location_Center_Y, colour = celltype)) +    geom_point() + theme(panel.background=element_blank(),         axis.line=element_line(color=\"black\")) +   scale_colour_manual(values = cell_colors) +  # Use named vector   ggtitle(\"Patient MB-0128 - high L value with \\n B cells interacting Fibroblasts\")  # Low L-function value plot. one_sample$celltype <- one_sample$description index <- one_sample$celltype %in% c(\"Fibroblasts\", \"HR- CK7-\") one_sample$celltype[!index] <- \"others\" b <- ggplot(one_sample, aes(x = Location_Center_X, y = Location_Center_Y, colour = celltype)) +    geom_point() + theme(panel.background=element_blank(),         axis.line=element_line(color=\"black\")) +   scale_colour_manual(values = cell_colors) +  # Use named vector   ggtitle(\"Patient MB-0128 - low L value with \\n B cells interacting HR_ CK7\")  ggarrange(plotlist = list(a, b)) feature <- scfeatures_result$morans_I feature <- feature[ grep(\"poor|good\", rownames(feature )),  ]  top_features <- feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   group_by(variable) %>%   summarise(     cohens_d = (mean(value[Group == \"Good Prognosis\"]) - mean(value[Group == \"Poor Prognosis\"])),     .groups = \"drop\"   ) %>%   arrange(desc(abs(cohens_d))) %>%   slice_head(n = 5) %>%   pull(variable)  feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   filter(variable %in% c(top_features, \"Ki67\")) %>%  # Keep only top 5   ggplot(aes(y = reorder(variable,value), x = value, fill = Group)) +    geom_boxplot() + theme_bw() + labs(x = \"Moran's I\", y = \"Marker\")"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"4.1 How to create molecular representations of individuals for an ROI?","title":null,"text":", can consider regional information following code allows us create cell-type specific features region. use function “paste0” construct region-specific sub cell-types name celltype R object data_sce. simplicity, workshop, variable celltype R object data_sce refers region-specific sub-cell-types. total 13 different types features (feature_types) can choose generate. argument type refers type input data . either scrna (single-cell RNA-sequencing data), spatial_p (spatial proteomics data), spatial_t (single-cell spatial data). section, ignore spatial information generate non-spatial features, pseudobulking sample /cell type levels, overall expression, cell type proportions etc… Generate features ROI Association Study scFeatures code (Optional) scFeatures output (Optional) Suppose interested determining proportion cell-types within region individual. necessary specify type = spatial_p reflect spatial proteomics data feature_types = proportion_raw indicate intend calculate cell-type proportions region-specific cell-types. Suppose interested molecular representation HR- CK7+ within individuals within region 5. Question regions associated “good” “poor” prognosis? right way visualise results?   Can identify “differential expression” feature interest? R object scfeatures_result contains variety features. important question focuses identification features reflect association prognostic outcome, specifically distinguishing good poor outcomes. code provided demonstrates use limma() function fit linear model purpose analysing gene_mean_celltype illustration feature type. feature type known gene_mean_celltype represents mean protein expression sub-cell-type specific spatial region. matrix consisting 77 individuals 4180 features. important acknowledge within context IMC data, term “gene” used refer “protein”. visualise comparison using volcano plot dotplot cell-type specific expression feature. type scatter-plot used quickly identify changes large datasets represent significance (y-axis) versus effect size fold-change (x-axis).  code enable us generate feature types cell-types line. Due limitations today’s computational capacity, Please run today’s workshop, crash system. Assuming already generated collection molecular representation individuals, please load prepared RDS file scfeatures_result.RDS. , can remind generated feature types stored matrix samples x features.","code":"## [A] The next few lines extract specific information from data_sce as input to scFeatures.  ## Extract the expression matrix from data_sce IMCmatrix <- assay(data_sce, \"norm\")  ## Extract the sample information  ## append the condition to the individuals so we can easily retrieve the individuals condition  sample <- data_sce$metabricId  cond  <- clinical[match(sample, clinical$metabricId), ]$survivalgroup sample <- paste0(sample, \"_cond_\", cond )   ## Extract the region-specific sub-cell-types celltype <- data_sce$celltype  ## Extract the spatial coordinates spatialCoords <- list(colData(data_sce)$Location_Center_X, colData(data_sce)$Location_Center_Y)  ### [B] Running scFeatures scfeatures_result <- scFeatures(IMCmatrix,                                  sample = sample,                                  celltype = celltype,                                  spatialCoords = spatialCoords,                                 feature_types = \"proportion_raw\",                                  type = \"spatial_p\" ) ## [A] The next few lines extract specific information from data_sce as input to scFeatures.  ## Select the HR- CK7+-region sub-cell-type   # There are different ways you can use `scFeatures` to generate molecular representations for individuals and it requires the following information for spatial data. #  # data,\\ # sample, # X coordinates, # Y coordinates, # feature_types, and # type  index <- grep(\"HR- CK7+-region\" , data_sce$celltype, fixed=TRUE) selected_data <- IMCmatrix[, index] selected_sample <- sample[index] selected_celltype <- data_sce$celltype[ index]  selected_spatialCoords <- list(colData(data_sce)$Location_Center_X[index],                                 colData(data_sce)$Location_Center_Y[index])  ### [B] Running scFeatures scfeatures_result <- scFeatures( selected_data,                                   sample = selected_sample,                                   celltype = selected_celltype,                                  spatialCoords = selected_spatialCoords,                                  feature_types = \"proportion_raw\", type = \"spatial_p\" )  ### [C] Visualize the regional composition makeup for each individual for HR- CK7+ and HR- CK7- feature <- scfeatures_result$proportion_raw feature <- feature[ grep(\"poor|good\", rownames(feature)),  ]  plot_barplot(feature ) + ggtitle(\"Proportion raw feature\") + labs(y = \"proportion\\n\") scfeatures_result <- readRDS(\"../data/scfeatures_result.RDS\") # Extract cell-type specific gene expression for all regions.  gene_mean_celltype <- scfeatures_result$gene_mean_celltype  # Extract HR+ CK7 cell-type specific gene expression for Region5 index <-  grep(\"HR+ CK7--region5\", colnames(gene_mean_celltype) , fixed= T) gene_mean_celltype <- gene_mean_celltype [, index]   # transpose to ensure we have gene by sample matrix gene_mean_celltype <- t(gene_mean_celltype)        # Extract the two conditions of interest - poor prognosis vs good prognosis condition  <- unlist( lapply( strsplit( colnames(gene_mean_celltype) , \"_cond_\"), `[`, 2)) condition <- data.frame(sample = colnames(gene_mean_celltype), condition = condition ) select_index <- which( condition$condition %in% c(\"poor\",  \"good\" )) condition <- condition[ select_index, ] gene_mean_celltype<- gene_mean_celltype [ ,  select_index]   # Calculate log fold change each protein using limma design <- model.matrix(~condition, data = condition) fit <- lmFit(gene_mean_celltype, design) fit <- eBayes(fit) tT <- topTable(fit, n = Inf) tT$gene <- rownames(tT) tT[1:6] <- signif(tT[1:6], digits=2) DT::datatable(tT) # order the proteins by log fold change  tT <- tT[ order(tT$logFC, decreasing = T), ] tT <- tT[1:20, ] ggplot( tT , aes( y = reorder(gene, logFC) , x = logFC  ) )+       geom_point(aes(colour=-log10(P.Value)), alpha=2/3, size=4) +       scale_colour_gradient(low=\"blue\",high=\"red\") + theme_bw() +        xlab(\"logFC\") + ylab(\"region specific cell type specfic features\" ) # here, we specify that this is a spatial proteomics data # scFeatures support parallel computation to speed up the process  # scfeatures_result <- scFeatures(IMCmatrix,  #                                 type = \"spatial_p\", #                                 sample = sample,  #                                 celltype = celltype,  #                                 spatialCoords = spatialCoords, #                                 ncores = 32) # Upload pre-generated RDS file scfeatures_result <- readRDS(\"../data/scfeatures_result.RDS\")  # What are the features and the dimensions of features matrices that we have generated? lapply(scfeatures_result, dim) $proportion_raw [1]  77 110  $proportion_logit [1]  77 110  $proportion_ratio [1]   77 5995  $gene_mean_celltype [1]   77 4180  $gene_prop_celltype [1]   77 4180  $gene_cor_celltype [1]    77 27958  $gene_mean_bulk [1] 77 38  $gene_prop_bulk [1] 77 38  $gene_cor_bulk [1]  77 703  $L_stats [1]   77 3842  $celltype_interaction [1]   77 4393  $morans_I [1] 77 38  $nn_correlation [1] 77 38"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"4.2 How can we represent spatial information and relationships for a given individual?","title":null,"text":"now look spatial statistic output scFeatures qualitively assess whether association statistics “good” “bad” prognosis groups. Questions kind information spatial statistics provide? differences distribution spatial statistics “good” “bad” prognosis groups?  Nearest neighbour correlation L statistics Moran’s metric measures correlation proteins/genes cell nearest neighbour cell.  L function spatial statistic used assess spatial distribution cell-types. assesses significance cell-cell interactions, calculating density cell-type cell-types within certain radius. High values indicate spatial association (co-localisation), low values indicate spatial avoidance. demonstrate L-function, plot specific patient “MB-0128” high L value B cells interacting Fibroblasts low L value B cells interacting HR- CK7- cells.  Moran’s spatial autocorrelation statistic based location values. quantifies whether similar values tend occur near dispersed.","code":"feature <- scfeatures_result$nn_correlation feature <- feature[ grep(\"poor|good\", rownames(feature )),  ]  top_features <- feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   group_by(variable) %>%   summarise(     cohens_d = (mean(value[Group == \"Good Prognosis\"]) - mean(value[Group == \"Poor Prognosis\"])) /sd(value),     .groups = \"drop\"   ) %>%   arrange(desc(abs(cohens_d))) %>%   slice_head(n = 5) %>%   pull(variable)  feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   filter(variable %in% top_features) %>%  # Keep only top 5   ggplot(aes(y = variable, x = value, fill = Group)) +    geom_boxplot() + theme_bw() + labs(x = \"Nearest Neighbour Correlation\", y = \"Marker\") tableau_palette <- scale_colour_tableau( palette = \"Tableau 20\") color_codes <- tableau_palette$palette(10)  # Create a named color vector cell_colors <- c(   \"B cells\" = color_codes[1],   \"Fibroblasts\" = color_codes[2],   \"HR- CK7-\" = color_codes[9],   \"others\" = color_codes[4] )  # select one patient  one_sample  <- data_sce[ , data_sce$metabricId == \"MB-0128\"  ] one_sample <- data.frame( colData(one_sample) )  one_sample$celltype <- one_sample$description  # High L-function value plot. one_sample <- data.frame(colData(data_sce[, data_sce$metabricId == \"MB-0128\"])) one_sample$celltype <- one_sample$description index <- one_sample$celltype %in% c(\"B cells\", \"Fibroblasts\") one_sample$celltype[!index] <- \"others\" a <- ggplot(one_sample, aes(x = Location_Center_X, y = Location_Center_Y, colour = celltype)) +    geom_point() + theme(panel.background=element_blank(),         axis.line=element_line(color=\"black\")) +   scale_colour_manual(values = cell_colors) +  # Use named vector   ggtitle(\"Patient MB-0128 - high L value with \\n B cells interacting Fibroblasts\")  # Low L-function value plot. one_sample$celltype <- one_sample$description index <- one_sample$celltype %in% c(\"Fibroblasts\", \"HR- CK7-\") one_sample$celltype[!index] <- \"others\" b <- ggplot(one_sample, aes(x = Location_Center_X, y = Location_Center_Y, colour = celltype)) +    geom_point() + theme(panel.background=element_blank(),         axis.line=element_line(color=\"black\")) +   scale_colour_manual(values = cell_colors) +  # Use named vector   ggtitle(\"Patient MB-0128 - low L value with \\n B cells interacting HR_ CK7\")  ggarrange(plotlist = list(a, b)) feature <- scfeatures_result$morans_I feature <- feature[ grep(\"poor|good\", rownames(feature )),  ]  top_features <- feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   group_by(variable) %>%   summarise(     cohens_d = (mean(value[Group == \"Good Prognosis\"]) - mean(value[Group == \"Poor Prognosis\"])),     .groups = \"drop\"   ) %>%   arrange(desc(abs(cohens_d))) %>%   slice_head(n = 5) %>%   pull(variable)  feature %>%   mutate(Group = ifelse(grepl(\"good\", rownames(feature)), \"Good Prognosis\", \"Poor Prognosis\")) %>%   pivot_longer(cols = -Group, names_to = \"variable\", values_to = \"value\") %>%   filter(variable %in% c(top_features, \"Ki67\")) %>%  # Keep only top 5   ggplot(aes(y = reorder(variable,value), x = value, fill = Group)) +    geom_boxplot() + theme_bw() + labs(x = \"Moran's I\", y = \"Marker\")"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Part 5: Disease classification with ClassifyR [Presentation]","title":null,"text":"Recurrence risk estimation fundamental concern medical research, particularly context patient survival analysis. section, estimate recurrence risk using molecular representation individuals generated scFeatures build survival model. use classifyR build survival model. patient outcome time--event, , default, ClassifyR use Cox proportional hazards ranking choose set features also Cox proportional hazards predict risk scores. also demonstrate available models ClassifyR. Questions spatial features globally informative predicting survival? , individuals important predicting survival?  Building survival model (Optional) Model performance (Optional) spatial information matter? Recall previous section stored 13 matrices different feature types list. Instead manually retrieving matrix list build separate models, classifyR can directly take list matrices input run repeated cross-validation model matrix individually. , run 5 repeats 5-fold cross-validation. high score indicates prognosis worse outcome lower risk score. Although provided code , save time, just load prepared RDS file classifyr_result_IMC.rds focus interpretation workshop. Cox proportional hazards classical statistical method, opposed machine learning methods like Random survival forest. machine learning methods can build remarkably complex relationships features, however running time can much longer Cox proportional hazards. use feature selection limit number features considered 100 per metafeature save time, can just load prepared RDS file. compare predictive performance methods. examine distribution prognostic performance, use performancePlot. Currently, metric time--event data C-index automatically used predictive model type tracked inside result objects.  Note resultant plot ggplot2 object can modified. code used categorical classifier random forest implementation provided ranger package interface . examine feature selection stability selectionPlot.  individual require different collection features? Using samplesMetricMap compare per-sample C-index Cox models kinds metafeatures.","code":"# We use the following variables:      # timeRFS: \"Time to Recurrence-Free Survival.\" It is the time period until recurrence occurs.     # eventRFS: \"Event in Recurrence-Free Survival.\"It indicates whether the event has occurred.     # Breast.Tumour.Laterality: Laterality of tumors, eg, whether the tumor is located in left or right.      # ER.Status: Whether the tumor is ER positive or ER negative.     # Inferred.Menopausal.State: of the patient.     # Grade: of the tumor.    # Size: of the tumor.     usefulFeatures <- c(\"Breast.Tumour.Laterality\", \"ER.Status\", \"Inferred.Menopausal.State\", \"Grade\", \"Size\") nFeatures <- append(list(clinical = 1:3), lapply(scfeatures_result, function(metaFeature) 1:5)) clinicalAndOmics <- append(list(clinical = clinical), scfeatures_result)  ### generate classfyr result  classifyr_result_IMC <- crossValidate(clinicalAndOmics, c(\"timeRFS\", \"eventRFS\"),                     extraParams = list(prepare = list(useFeatures = list(clinical = usefulFeatures))),                     nFeatures = nFeatures, nFolds = 5, nRepeats = 5, nCores = 5) classifyr_result_IMC <- readRDS(\"../data/classifyr_result_IMC.rds\") nFeatures <- append(list(clinical = 1:3), lapply(scfeatures_result[2:length(scfeatures_result)], function(metaFeature) min(100, ncol(metaFeature)))) survForestCV <- crossValidate(clinicalAndOmics, outcome, nFeatures = nFeatures,                 classifier = \"randomForest\",                 nFolds = 5, nRepeats = 5, nCores = 5) survForestCV <- readRDS(\"../data/survForestCV.RDS\") ## Make axis label 45 degree to improve readiability  tilt <- theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))  ## Putting two sets of cross-validation results together multiresults <- append(classifyr_result_IMC, survForestCV) ordering <- c(\"clinical\", names(scfeatures_result)) performancePlot(multiresults,                 characteristicsList = list(x = \"Assay Name\",                                             row = \"Classifier Name\"),                 orderingList = list(\"Assay Name\" = ordering)) +                  tilt selectionPlot(multiresults,                 characteristicsList = list(x = \"Assay Name\", row = \"Classifier Name\"),                 orderingList = list(\"Assay Name\" = ordering)) + tilt distribution(classifyr_result_IMC[[1]], plot = FALSE) assay                   feature proportion 1 clinical Inferred.Menopausal.State          1 library(grid) samplesMetricMap(classifyr_result_IMC) TableGrob (2 x 1) \"arrange\": 2 grobs   z     cells    name                 grob 1 1 (2-2,1-1) arrange       gtable[layout] 2 2 (1-1,1-1) arrange text[GRID.text.8769]"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Appendix","title":null,"text":"L function: L function spatial statistic used assess spatial distribution cell-types. assesses significance cell-cell interactions, calculating density cell-type cell-types within certain radius. High values indicate spatial association (co-localisation), low values indicate spatial avoidance.  Cell type interaction composition: calculate nearest neighbours cell calculate pairs cell-types based nearest neighbour. allows us summarise cell-type interaction composition.  Moran’s : Moran’s spatial autocorrelation statistic based location values. quantifies whether similar values tend occur near dispersed.  Nearest Neighbor Correlation: metric measures correlation proteins/genes cell nearest neighbour cell.  authors thank colleagues, particularly University Sydney, Sydney Precision Data Science Charles Perkins Centre support intellectual engagement. Special thanks Ellis Patrick, Shila Ghazanfar, Andy Tran, Helen, Daniel guiding supporting building workshop.","code":"tableau_palette <- scale_colour_tableau( palette = \"Tableau 20\") color_codes <- tableau_palette$palette(10) # select one patient  one_sample  <- data_sce[ , data_sce$metabricId == \"MB-0128\"  ] one_sample <- data.frame( colData(one_sample) )  one_sample$celltype <- one_sample$description  # select certain cell types to examine the interaction  index <-  one_sample$celltype  %in% c(\"B cells\", \"Fibroblasts\") one_sample$celltype[!index] <- \"others\" a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( \"Patient MB-0128 - high L value with \\n B cells interacting Fibroblasts\")    one_sample$celltype <- one_sample$description index <-  one_sample$celltype  %in% c(\"Fibroblasts\", \"HR- CK7-\") one_sample$celltype[!index] <- \"others\" b <- ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( \"Patient MB-0128 - low L value with \\n B cells interacting HR_ CK7\")   ggarrange(plotlist = list(a,b)) one_sample  <- data_sce[ , data_sce$metabricId == \"MB-0263\"  ] one_sample <- data.frame( colData(one_sample) )  one_sample$celltype <- one_sample$description   a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle(\"Patient MB-0263\")  feature  <- scfeatures_result$celltype_interaction to_plot <- data.frame( t( feature[ \"MB-0263_cond_poor\" , ])  ) to_plot$feature <- rownames(to_plot)  colnames(to_plot) <- c(\"value\", \"celltype interaction composition\")   to_plot <- to_plot[ order(to_plot$value, decreasing = T), ] to_plot <- to_plot[1:10, ] to_plot$`celltype interaction composition` <- factor(to_plot$`celltype interaction composition`, levels = to_plot$`celltype interaction composition`)  b <- ggplot(to_plot, aes(x =  `celltype interaction composition`  ,  y = value, fill=`celltype interaction composition`)) + geom_bar(stat=\"identity\" ) + ylab(\"Major cell-type interactions\")  +   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))   ggarrange(plotlist = list(a,b)) high  <- data_sce[\"Ki67\", data_sce$metabricId == \"MB-0132\"  ] high_meta <- data.frame( colData(high) )  high_meta$expression <- as.vector(logcounts( high))   low  <- data_sce[\"Ki67\",  data_sce$metabricId == \"MB-0249\" ] low_meta <- data.frame( colData(low) ) low_meta$expression <- as.vector(logcounts(low))   a <- ggplot(high_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle(\"Patient MB-0132 - high Moran's I in Ki67\")  b <- ggplot(low_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle(\"Patient MB-0249 - low Moran's I in Ki67\")  ggarrange(plotlist = list(a,b)) plot_nncorrelation <- function(thissample , thisprotein){            sample_name <- thissample        thissample <- data_sce[, data_sce$metabricId ==     sample_name]                   exprsMat <- logcounts(thissample)           # calculate NN correlation      cell_points_cts <- spatstat.geom::ppp(             x = as.numeric(thissample$Location_Center_X ), y = as.numeric(thissample$Location_Center_Y),             check = FALSE,             xrange = c(                 min(as.numeric(thissample$Location_Center_X)),                 max(as.numeric(thissample$Location_Center_X))             ),             yrange = c(                 min(as.numeric(thissample$Location_Center_Y)),                 max(as.numeric(thissample$Location_Center_Y))             ),             marks = t(as.matrix(exprsMat))         )           value <-  spatstat.explore::nncorr(cell_points_cts)[\"correlation\", ]       value <-  value[  thisprotein]           # Find the indices of the two nearest neighbors for each cell     nn_indices <- nnwhich(cell_points_cts, k = 1)          protein <-  thisprotein     df <- data.frame(thiscell_exprs  = exprsMat[protein, ] , exprs =  exprsMat[protein,nn_indices ])         p <-  ggplot(df, aes( x =thiscell_exprs ,  y = exprs , colour =  exprs  )) +       geom_point(alpha = 0.3) + ggtitle(paste0( \"Patient \", sample_name ,  \" nn_corr = \" ,  round(value, 2)  )) + scale_colour_viridis_c() + xlab(\"This cell expression\") + ylab(\"Neighbouring cell expression\")        return (p )   }       p1 <- plot_nncorrelation(\"MB-0605\",  \"HER2\") p2 <- plot_nncorrelation(\"MB-0258\",  \"HER2\")  ggarrange(plotlist = list(p1, p2)) sessionInfo() R version 4.4.2 (2024-10-31) Platform: aarch64-apple-darwin20 Running under: macOS Sequoia 15.6.1  Matrix products: default BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib  LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0  locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8  time zone: Asia/Singapore tzcode source: internal  attached base packages: [1] grid      stats4    stats     graphics  grDevices utils     datasets  [8] methods   base       other attached packages:  [1] cowplot_1.2.0               SpatialExperiment_1.16.0     [3] Banksy_1.2.0                cytomapper_1.18.0            [5] EBImage_4.48.0              purrr_1.1.0                  [7] simpleSeg_1.8.1             naniar_1.1.0                 [9] reshape_0.8.10              scran_1.34.0                [11] scater_1.34.1               scuttle_1.16.0              [13] spatstat_3.4-1              spatstat.linnet_3.3-2       [15] spatstat.model_3.4-2        rpart_4.1.24                [17] spatstat.explore_3.5-3      nlme_3.1-168                [19] spatstat.random_3.4-2       spatstat.geom_3.6-0         [21] spatstat.univar_3.1-4       spatstat.data_3.1-9         [23] survminer_0.5.1             ggpubr_0.6.2                [25] tidyr_1.3.1                 scattermore_1.2             [27] plotly_4.11.0               limma_3.62.2                [29] dplyr_1.1.4                 spicyR_1.18.1               [31] pheatmap_1.0.13             ggthemes_5.1.0              [33] lisaClust_1.14.4            ClassifyR_3.11.6            [35] survival_3.8-3              BiocParallel_1.40.2         [37] MultiAssayExperiment_1.32.0 generics_0.1.4              [39] scFeatures_1.6.0            ggplot2_4.0.0               [41] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 [43] Biobase_2.66.0              GenomicRanges_1.58.0        [45] GenomeInfoDb_1.42.3         IRanges_2.40.1              [47] S4Vectors_0.44.0            BiocGenerics_0.52.0         [49] MatrixGenerics_1.18.1       matrixStats_1.5.0            loaded via a namespace (and not attached):   [1] R.methodsS3_1.8.2          GSEABase_1.68.0              [3] tiff_0.1-12                dcanr_1.22.0                 [5] EnsDb.Mmusculus.v79_2.99.0 DT_0.34.0                    [7] goftest_1.2-3              Biostrings_2.74.1            [9] HDF5Array_1.34.0           vctrs_0.6.5                 [11] digest_0.6.37              png_0.1-8                   [13] shape_1.4.6.1              EnsDb.Hsapiens.v79_2.99.0   [15] ggrepel_0.9.6              deldir_2.0-4                [17] magick_2.9.0               MASS_7.3-65                 [19] reshape2_1.4.4             foreach_1.5.2               [21] httpuv_1.6.16              withr_3.0.2                 [23] xfun_0.53                  doRNG_1.8.6.2               [25] memoise_2.0.1              proxyC_0.5.2                [27] ggbeeswarm_0.7.2           systemfonts_1.3.1           [29] zoo_1.8-14                 GlobalOptions_0.1.2         [31] gtools_3.9.5               V8_8.0.1                    [33] SingleCellSignalR_1.18.0   R.oo_1.27.1                 [35] Formula_1.2-5              KEGGREST_1.46.0             [37] promises_1.4.0             otel_0.2.0                  [39] httr_1.4.7                 rstatix_0.7.3               [41] restfulr_0.0.16            rhdf5filters_1.18.1         [43] rhdf5_2.50.2               rstudioapi_0.17.1           [45] UCSC.utils_1.2.0           concaveman_1.2.0            [47] babelgene_22.9             curl_7.0.0                  [49] zlibbioc_1.52.0            ScaledMatrix_1.14.0         [51] polyclip_1.10-7            GenomeInfoDbData_1.2.13     [53] SparseArray_1.6.2          fftwtools_0.9-11            [55] xtable_1.8-4               stringr_1.5.2               [57] evaluate_1.0.5             S4Arrays_1.6.0              [59] irlba_2.3.5.1              colorspace_2.1-2            [61] magrittr_2.0.4             later_1.4.4                 [63] viridis_0.6.5              lattice_0.22-7              [65] XML_3.99-0.19              ggupset_0.4.1               [67] svgPanZoom_0.3.4           class_7.3-23                [69] pillar_1.11.1              iterators_1.0.14            [71] caTools_1.18.3             compiler_4.4.2              [73] beachmat_2.22.0            stringi_1.8.7               [75] tensor_1.5.1               minqa_1.2.8                 [77] GenomicAlignments_1.42.0   plyr_1.8.9                  [79] msigdbr_25.1.1             crayon_1.5.3                [81] abind_1.4-8                BiocIO_1.16.0               [83] sp_2.2-0                   locfit_1.5-9.12             [85] terra_1.8-70               bit_4.6.0                   [87] textshaping_1.0.4          codetools_0.2-20            [89] BiocSingular_1.22.0        crosstalk_1.2.2             [91] bslib_0.9.0                mime_0.13                   [93] multtest_2.62.0            splines_4.4.2               [95] circlize_0.4.16            Rcpp_1.1.0                  [97] sparseMatrixStats_1.18.0   knitr_1.50                  [99] blob_1.2.4                 AnnotationFilter_1.30.0    [101] lme4_1.1-37                nnls_1.6                   [103] DelayedMatrixStats_1.28.1  Rdpack_2.6.4               [105] GSVA_2.0.7                 RcppHungarian_0.3          [107] ggsignif_0.6.4             tibble_3.3.0               [109] Matrix_1.7-4               scam_1.2-20                [111] statmod_1.5.1              svglite_2.2.2              [113] visdat_0.6.0               tweenr_2.0.3               [115] pkgconfig_2.0.3            tools_4.4.2                [117] aricode_1.0.3              cachem_1.1.0               [119] rbibutils_2.3              RSQLite_2.4.3              [121] viridisLite_0.4.2          DBI_1.2.3                  [123] numDeriv_2016.8-1.1        fastmap_1.2.0              [125] rmarkdown_2.30             scales_1.4.0               [127] shinydashboard_0.7.3       Rsamtools_2.22.0           [129] sass_0.4.10                broom_1.0.10               [131] BiocManager_1.30.26        graph_1.84.1               [133] carData_3.0-5              farver_2.1.2               [135] reformulas_0.4.2           mgcv_1.9-3                 [137] yaml_2.3.10                rtracklayer_1.66.0         [139] cli_3.6.5                  dbscan_1.2.3               [141] lifecycle_1.0.4            uwot_0.2.3                 [143] bluster_1.16.0             backports_1.5.0            [145] annotate_1.84.0            gtable_0.3.6               [147] rjson_0.2.23               parallel_4.4.2             [149] ape_5.8-1                  jsonlite_2.0.0             [151] edgeR_4.4.2                bitops_1.0-9               [153] bit64_4.6.0-1              assertthat_0.2.1           [155] Rtsne_0.17                 spatstat.utils_3.2-0       [157] BiocNeighbors_2.0.1        bdsmatrix_1.3-7            [159] jquerylib_0.1.4            metapod_1.14.0             [161] dqrng_0.4.1                survMisc_0.5.6             [163] R.utils_2.13.0             lazyeval_0.2.2             [165] shiny_1.11.1               htmltools_0.5.8.1          [167] KMsurv_0.1-6               ensembldb_2.30.0           [169] glue_1.8.0                 XVector_0.46.0             [171] RCurl_1.98-1.17            mclust_6.1.1               [173] coxme_2.2-22               jpeg_0.1-11                [175] gridExtra_2.3              AUCell_1.28.0              [177] sccore_1.0.6               boot_1.3-32                [179] igraph_2.2.1               R6_2.6.1                   [181] gplots_3.2.0               labeling_0.4.3             [183] km.ci_0.5-6                ggh4x_0.3.1                [185] GenomicFeatures_1.58.0     cluster_2.1.8.1            [187] rngtools_1.5.2             Rhdf5lib_1.28.0            [189] nloptr_2.2.1               DelayedArray_0.32.0        [191] tidyselect_1.2.1           vipor_0.4.7                [193] ProtGenerics_1.38.0        raster_3.6-32              [195] ggforce_0.5.0              car_3.1-3                  [197] leidenAlg_1.1.5            AnnotationDbi_1.68.0       [199] rsvd_1.0.5                 KernSmooth_2.23-26         [201] S7_0.2.0                   data.table_1.17.8          [203] htmlwidgets_1.6.4          RColorBrewer_1.1-3         [205] rlang_1.1.6                spatstat.sparse_3.1-0      [207] lmerTest_3.1-3             ggnewscale_0.5.2           [209] beeswarm_0.4.0"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Explanation of spatial features","title":null,"text":"L function: L function spatial statistic used assess spatial distribution cell-types. assesses significance cell-cell interactions, calculating density cell-type cell-types within certain radius. High values indicate spatial association (co-localisation), low values indicate spatial avoidance.  Cell type interaction composition: calculate nearest neighbours cell calculate pairs cell-types based nearest neighbour. allows us summarise cell-type interaction composition.  Moran’s : Moran’s spatial autocorrelation statistic based location values. quantifies whether similar values tend occur near dispersed.  Nearest Neighbor Correlation: metric measures correlation proteins/genes cell nearest neighbour cell.","code":"tableau_palette <- scale_colour_tableau( palette = \"Tableau 20\") color_codes <- tableau_palette$palette(10) # select one patient  one_sample  <- data_sce[ , data_sce$metabricId == \"MB-0128\"  ] one_sample <- data.frame( colData(one_sample) )  one_sample$celltype <- one_sample$description  # select certain cell types to examine the interaction  index <-  one_sample$celltype  %in% c(\"B cells\", \"Fibroblasts\") one_sample$celltype[!index] <- \"others\" a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( \"Patient MB-0128 - high L value with \\n B cells interacting Fibroblasts\")    one_sample$celltype <- one_sample$description index <-  one_sample$celltype  %in% c(\"Fibroblasts\", \"HR- CK7-\") one_sample$celltype[!index] <- \"others\" b <- ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle( \"Patient MB-0128 - low L value with \\n B cells interacting HR_ CK7\")   ggarrange(plotlist = list(a,b)) one_sample  <- data_sce[ , data_sce$metabricId == \"MB-0263\"  ] one_sample <- data.frame( colData(one_sample) )  one_sample$celltype <- one_sample$description   a <-ggplot( one_sample, aes(x = Location_Center_X , y = Location_Center_Y, colour = celltype )) + geom_point()  + scale_colour_manual(values = color_codes)  + ggtitle(\"Patient MB-0263\")  feature  <- scfeatures_result$celltype_interaction to_plot <- data.frame( t( feature[ \"MB-0263_cond_poor\" , ])  ) to_plot$feature <- rownames(to_plot)  colnames(to_plot) <- c(\"value\", \"celltype interaction composition\")   to_plot <- to_plot[ order(to_plot$value, decreasing = T), ] to_plot <- to_plot[1:10, ] to_plot$`celltype interaction composition` <- factor(to_plot$`celltype interaction composition`, levels = to_plot$`celltype interaction composition`)  b <- ggplot(to_plot, aes(x =  `celltype interaction composition`  ,  y = value, fill=`celltype interaction composition`)) + geom_bar(stat=\"identity\" ) + ylab(\"Major cell-type interactions\")  +   theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))   ggarrange(plotlist = list(a,b)) high  <- data_sce[\"Ki67\", data_sce$metabricId == \"MB-0132\"  ] high_meta <- data.frame( colData(high) )  high_meta$expression <- as.vector(logcounts( high))   low  <- data_sce[\"Ki67\",  data_sce$metabricId == \"MB-0249\" ] low_meta <- data.frame( colData(low) ) low_meta$expression <- as.vector(logcounts(low))   a <- ggplot(high_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle(\"Patient MB-0132 - high Moran's I in Ki67\")  b <- ggplot(low_meta, aes(x = Location_Center_X , y = Location_Center_Y, colour =expression)) + geom_point(alpha=0.5) + scale_colour_viridis_c() + ggtitle(\"Patient MB-0249 - low Moran's I in Ki67\")  ggarrange(plotlist = list(a,b)) plot_nncorrelation <- function(thissample , thisprotein){            sample_name <- thissample        thissample <- data_sce[, data_sce$metabricId ==     sample_name]                   exprsMat <- logcounts(thissample)           # calculate NN correlation      cell_points_cts <- spatstat.geom::ppp(             x = as.numeric(thissample$Location_Center_X ), y = as.numeric(thissample$Location_Center_Y),             check = FALSE,             xrange = c(                 min(as.numeric(thissample$Location_Center_X)),                 max(as.numeric(thissample$Location_Center_X))             ),             yrange = c(                 min(as.numeric(thissample$Location_Center_Y)),                 max(as.numeric(thissample$Location_Center_Y))             ),             marks = t(as.matrix(exprsMat))         )           value <-  spatstat.explore::nncorr(cell_points_cts)[\"correlation\", ]       value <-  value[  thisprotein]           # Find the indices of the two nearest neighbors for each cell     nn_indices <- nnwhich(cell_points_cts, k = 1)          protein <-  thisprotein     df <- data.frame(thiscell_exprs  = exprsMat[protein, ] , exprs =  exprsMat[protein,nn_indices ])         p <-  ggplot(df, aes( x =thiscell_exprs ,  y = exprs , colour =  exprs  )) +       geom_point(alpha = 0.3) + ggtitle(paste0( \"Patient \", sample_name ,  \" nn_corr = \" ,  round(value, 2)  )) + scale_colour_viridis_c() + xlab(\"This cell expression\") + ylab(\"Neighbouring cell expression\")        return (p )   }       p1 <- plot_nncorrelation(\"MB-0605\",  \"HER2\") p2 <- plot_nncorrelation(\"MB-0258\",  \"HER2\")  ggarrange(plotlist = list(p1, p2))"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"SessionInfo","title":null,"text":"","code":"sessionInfo() R version 4.4.2 (2024-10-31) Platform: aarch64-apple-darwin20 Running under: macOS Sequoia 15.6.1  Matrix products: default BLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib  LAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0  locale: [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8  time zone: Asia/Singapore tzcode source: internal  attached base packages: [1] grid      stats4    stats     graphics  grDevices utils     datasets  [8] methods   base       other attached packages:  [1] cowplot_1.2.0               SpatialExperiment_1.16.0     [3] Banksy_1.2.0                cytomapper_1.18.0            [5] EBImage_4.48.0              purrr_1.1.0                  [7] simpleSeg_1.8.1             naniar_1.1.0                 [9] reshape_0.8.10              scran_1.34.0                [11] scater_1.34.1               scuttle_1.16.0              [13] spatstat_3.4-1              spatstat.linnet_3.3-2       [15] spatstat.model_3.4-2        rpart_4.1.24                [17] spatstat.explore_3.5-3      nlme_3.1-168                [19] spatstat.random_3.4-2       spatstat.geom_3.6-0         [21] spatstat.univar_3.1-4       spatstat.data_3.1-9         [23] survminer_0.5.1             ggpubr_0.6.2                [25] tidyr_1.3.1                 scattermore_1.2             [27] plotly_4.11.0               limma_3.62.2                [29] dplyr_1.1.4                 spicyR_1.18.1               [31] pheatmap_1.0.13             ggthemes_5.1.0              [33] lisaClust_1.14.4            ClassifyR_3.11.6            [35] survival_3.8-3              BiocParallel_1.40.2         [37] MultiAssayExperiment_1.32.0 generics_0.1.4              [39] scFeatures_1.6.0            ggplot2_4.0.0               [41] SingleCellExperiment_1.28.1 SummarizedExperiment_1.36.0 [43] Biobase_2.66.0              GenomicRanges_1.58.0        [45] GenomeInfoDb_1.42.3         IRanges_2.40.1              [47] S4Vectors_0.44.0            BiocGenerics_0.52.0         [49] MatrixGenerics_1.18.1       matrixStats_1.5.0            loaded via a namespace (and not attached):   [1] R.methodsS3_1.8.2          GSEABase_1.68.0              [3] tiff_0.1-12                dcanr_1.22.0                 [5] EnsDb.Mmusculus.v79_2.99.0 DT_0.34.0                    [7] goftest_1.2-3              Biostrings_2.74.1            [9] HDF5Array_1.34.0           vctrs_0.6.5                 [11] digest_0.6.37              png_0.1-8                   [13] shape_1.4.6.1              EnsDb.Hsapiens.v79_2.99.0   [15] ggrepel_0.9.6              deldir_2.0-4                [17] magick_2.9.0               MASS_7.3-65                 [19] reshape2_1.4.4             foreach_1.5.2               [21] httpuv_1.6.16              withr_3.0.2                 [23] xfun_0.53                  doRNG_1.8.6.2               [25] memoise_2.0.1              proxyC_0.5.2                [27] ggbeeswarm_0.7.2           systemfonts_1.3.1           [29] zoo_1.8-14                 GlobalOptions_0.1.2         [31] gtools_3.9.5               V8_8.0.1                    [33] SingleCellSignalR_1.18.0   R.oo_1.27.1                 [35] Formula_1.2-5              KEGGREST_1.46.0             [37] promises_1.4.0             otel_0.2.0                  [39] httr_1.4.7                 rstatix_0.7.3               [41] restfulr_0.0.16            rhdf5filters_1.18.1         [43] rhdf5_2.50.2               rstudioapi_0.17.1           [45] UCSC.utils_1.2.0           concaveman_1.2.0            [47] babelgene_22.9             curl_7.0.0                  [49] zlibbioc_1.52.0            ScaledMatrix_1.14.0         [51] polyclip_1.10-7            GenomeInfoDbData_1.2.13     [53] SparseArray_1.6.2          fftwtools_0.9-11            [55] xtable_1.8-4               stringr_1.5.2               [57] evaluate_1.0.5             S4Arrays_1.6.0              [59] irlba_2.3.5.1              colorspace_2.1-2            [61] magrittr_2.0.4             later_1.4.4                 [63] viridis_0.6.5              lattice_0.22-7              [65] XML_3.99-0.19              ggupset_0.4.1               [67] svgPanZoom_0.3.4           class_7.3-23                [69] pillar_1.11.1              iterators_1.0.14            [71] caTools_1.18.3             compiler_4.4.2              [73] beachmat_2.22.0            stringi_1.8.7               [75] tensor_1.5.1               minqa_1.2.8                 [77] GenomicAlignments_1.42.0   plyr_1.8.9                  [79] msigdbr_25.1.1             crayon_1.5.3                [81] abind_1.4-8                BiocIO_1.16.0               [83] sp_2.2-0                   locfit_1.5-9.12             [85] terra_1.8-70               bit_4.6.0                   [87] textshaping_1.0.4          codetools_0.2-20            [89] BiocSingular_1.22.0        crosstalk_1.2.2             [91] bslib_0.9.0                mime_0.13                   [93] multtest_2.62.0            splines_4.4.2               [95] circlize_0.4.16            Rcpp_1.1.0                  [97] sparseMatrixStats_1.18.0   knitr_1.50                  [99] blob_1.2.4                 AnnotationFilter_1.30.0    [101] lme4_1.1-37                nnls_1.6                   [103] DelayedMatrixStats_1.28.1  Rdpack_2.6.4               [105] GSVA_2.0.7                 RcppHungarian_0.3          [107] ggsignif_0.6.4             tibble_3.3.0               [109] Matrix_1.7-4               scam_1.2-20                [111] statmod_1.5.1              svglite_2.2.2              [113] visdat_0.6.0               tweenr_2.0.3               [115] pkgconfig_2.0.3            tools_4.4.2                [117] aricode_1.0.3              cachem_1.1.0               [119] rbibutils_2.3              RSQLite_2.4.3              [121] viridisLite_0.4.2          DBI_1.2.3                  [123] numDeriv_2016.8-1.1        fastmap_1.2.0              [125] rmarkdown_2.30             scales_1.4.0               [127] shinydashboard_0.7.3       Rsamtools_2.22.0           [129] sass_0.4.10                broom_1.0.10               [131] BiocManager_1.30.26        graph_1.84.1               [133] carData_3.0-5              farver_2.1.2               [135] reformulas_0.4.2           mgcv_1.9-3                 [137] yaml_2.3.10                rtracklayer_1.66.0         [139] cli_3.6.5                  dbscan_1.2.3               [141] lifecycle_1.0.4            uwot_0.2.3                 [143] bluster_1.16.0             backports_1.5.0            [145] annotate_1.84.0            gtable_0.3.6               [147] rjson_0.2.23               parallel_4.4.2             [149] ape_5.8-1                  jsonlite_2.0.0             [151] edgeR_4.4.2                bitops_1.0-9               [153] bit64_4.6.0-1              assertthat_0.2.1           [155] Rtsne_0.17                 spatstat.utils_3.2-0       [157] BiocNeighbors_2.0.1        bdsmatrix_1.3-7            [159] jquerylib_0.1.4            metapod_1.14.0             [161] dqrng_0.4.1                survMisc_0.5.6             [163] R.utils_2.13.0             lazyeval_0.2.2             [165] shiny_1.11.1               htmltools_0.5.8.1          [167] KMsurv_0.1-6               ensembldb_2.30.0           [169] glue_1.8.0                 XVector_0.46.0             [171] RCurl_1.98-1.17            mclust_6.1.1               [173] coxme_2.2-22               jpeg_0.1-11                [175] gridExtra_2.3              AUCell_1.28.0              [177] sccore_1.0.6               boot_1.3-32                [179] igraph_2.2.1               R6_2.6.1                   [181] gplots_3.2.0               labeling_0.4.3             [183] km.ci_0.5-6                ggh4x_0.3.1                [185] GenomicFeatures_1.58.0     cluster_2.1.8.1            [187] rngtools_1.5.2             Rhdf5lib_1.28.0            [189] nloptr_2.2.1               DelayedArray_0.32.0        [191] tidyselect_1.2.1           vipor_0.4.7                [193] ProtGenerics_1.38.0        raster_3.6-32              [195] ggforce_0.5.0              car_3.1-3                  [197] leidenAlg_1.1.5            AnnotationDbi_1.68.0       [199] rsvd_1.0.5                 KernSmooth_2.23-26         [201] S7_0.2.0                   data.table_1.17.8          [203] htmlwidgets_1.6.4          RColorBrewer_1.1-3         [205] rlang_1.1.6                spatstat.sparse_3.1-0      [207] lmerTest_3.1-3             ggnewscale_0.5.2           [209] beeswarm_0.4.0"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/articles/NUS_workshop_v1.html","id":null,"dir":"Articles","previous_headings":"","what":"Acknowledgments","title":null,"text":"authors thank colleagues, particularly University Sydney, Sydney Precision Data Science Charles Perkins Centre support intellectual engagement. Special thanks Ellis Patrick, Shila Ghazanfar, Andy Tran, Helen, Daniel guiding supporting building workshop.","code":""},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sydney Data Science Centre. Author, maintainer.","code":""},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Sydney Data Science Centre (2025). NUS2025: Unlocking single cell spatial omics analyses SCDNEY. R package version 0.1.0, https://sydneybiox.github.io/2025_NUS_Workshop/.","code":"@Manual{,   title = {NUS2025: Unlocking single cell spatial omics analyses with SCDNEY},   author = {{Sydney Data Science Centre}},   year = {2025},   note = {R package version 0.1.0},   url = {https://sydneybiox.github.io/2025_NUS_Workshop/}, }"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/index.html","id":"unlocking-single-cell-and-spatial-analysis-with-scdney","dir":"","previous_headings":"","what":"Unlocking single cell spatial omics analyses with SCDNEY","title":"Unlocking single cell spatial omics analyses with SCDNEY","text":"Data can accessed dropbox: https://www.dropbox.com/scl/fi/dz6b40ykggdxb8qnkiu8t/data.zip?rlkey=bbmyo81x1hdbj4ex7pfxfyppj&st=n6a7gase&dl=1 Website https://sydneybiox.github.io/2025_NUS_Workshop/ Slide : TBA","code":""},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/reference/hello.html","id":null,"dir":"Reference","previous_headings":"","what":"Hello, World! — hello","title":"Hello, World! — hello","text":"Prints 'Hello, world!'.","code":""},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/reference/hello.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hello, World! — hello","text":"","code":"hello()"},{"path":"https://sydneybiox.github.io/2025_NUS_Workshop/reference/hello.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hello, World! — hello","text":"","code":"hello() #> [1] \"Hello, world!\""}]
